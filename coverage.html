
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>message-mirror: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">message-mirror/cmd/message-mirror/main.go (0.0%)</option>
				
				<option value="file1">message-mirror/internal/core/config.go (87.7%)</option>
				
				<option value="file2">message-mirror/internal/core/config_manager.go (0.0%)</option>
				
				<option value="file3">message-mirror/internal/core/config_test_extended.go (0.0%)</option>
				
				<option value="file4">message-mirror/internal/core/http_server.go (0.0%)</option>
				
				<option value="file5">message-mirror/internal/core/mirror.go (2.1%)</option>
				
				<option value="file6">message-mirror/internal/core/producer.go (0.0%)</option>
				
				<option value="file7">message-mirror/internal/pkg/deduplicator/deduplicator.go (54.2%)</option>
				
				<option value="file8">message-mirror/internal/pkg/deduplicator/deduplicator_test_extended.go (0.0%)</option>
				
				<option value="file9">message-mirror/internal/pkg/logger/logger.go (45.4%)</option>
				
				<option value="file10">message-mirror/internal/pkg/logger/logger_test_extended.go (0.0%)</option>
				
				<option value="file11">message-mirror/internal/pkg/metrics/metrics.go (97.1%)</option>
				
				<option value="file12">message-mirror/internal/pkg/optimization/optimization.go (70.9%)</option>
				
				<option value="file13">message-mirror/internal/pkg/optimization/optimization_test_extended.go (0.0%)</option>
				
				<option value="file14">message-mirror/internal/pkg/ratelimiter/ratelimiter.go (76.6%)</option>
				
				<option value="file15">message-mirror/internal/pkg/ratelimiter/ratelimiter_test_extended.go (0.0%)</option>
				
				<option value="file16">message-mirror/internal/pkg/retry/retry.go (48.5%)</option>
				
				<option value="file17">message-mirror/internal/pkg/security/security.go (62.3%)</option>
				
				<option value="file18">message-mirror/internal/pkg/version/version.go (0.0%)</option>
				
				<option value="file19">message-mirror/internal/plugins/file_plugin.go (66.0%)</option>
				
				<option value="file20">message-mirror/internal/plugins/kafka_plugin.go (36.8%)</option>
				
				<option value="file21">message-mirror/internal/plugins/plugin.go (91.7%)</option>
				
				<option value="file22">message-mirror/internal/plugins/rabbitmq_plugin.go (38.7%)</option>
				
				<option value="file23">message-mirror/web/ui.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "log"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/spf13/cobra"
        
        "message-mirror/internal/core"
        "message-mirror/internal/pkg/version"
)

var (
        configPath string
)

func main() <span class="cov0" title="0">{
        rootCmd := &amp;cobra.Command{
                Use:   "message-mirror",
                Short: "Kafka消息镜像工具",
                Long:  "一个用Go语言开发的Kafka消息镜像工具，用于在Kafka集群之间复制消息",
                RunE:  run,
        }

        rootCmd.Flags().StringVarP(&amp;configPath, "config", "c", "config.yaml", "配置文件路径")

        // 添加version命令
        versionCmd := &amp;cobra.Command{
                Use:   "version",
                Short: "显示版本信息",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        log.Printf("Message Mirror")
                        log.Printf("版本: %s", version.Version)
                        log.Printf("构建时间: %s", version.BuildTime)
                        log.Printf("Git提交: %s", version.GitCommit)
                }</span>,
        }
        <span class="cov0" title="0">rootCmd.AddCommand(versionCmd)

        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("执行失败: %v", err)
        }</span>
}

func run(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // 创建配置管理器
        configManager, err := core.NewConfigManager(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 获取配置
        <span class="cov0" title="0">config := configManager.GetConfig()

        log.Printf("配置加载成功: 源类型=%s, 目标集群=%v",
                config.Source.Type, config.Target.Brokers)

        // 创建MirrorMaker
        mirrorMaker, err := core.NewMirrorMaker(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 注册配置重载监听器
        <span class="cov0" title="0">configManager.RegisterListener(mirrorMaker)

        // 启动MirrorMaker
        if err := mirrorMaker.Start(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 启动HTTP服务器（如果启用）
        <span class="cov0" title="0">var httpServer *core.HTTPServer
        if config.Server.Enabled </span><span class="cov0" title="0">{
                metrics := mirrorMaker.GetMetrics()
                httpServer = core.NewHTTPServer(config.Server.Address, metrics, mirrorMaker, configManager, context.Background())
                if err := httpServer.Start(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("启动HTTP服务器失败: %v", err)
                }</span>
        }

        // 设置信号处理，实现优雅关闭
        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

        // 等待信号
        &lt;-sigChan
        log.Println("收到停止信号，正在关闭...")

        // 停止HTTP服务器
        if httpServer != nil </span><span class="cov0" title="0">{
                if err := httpServer.Stop(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("停止HTTP服务器失败: %v", err)
                }</span>
        }

        // 停止MirrorMaker
        <span class="cov0" title="0">if err := mirrorMaker.Stop(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 打印最终统计信息
        <span class="cov0" title="0">stats := mirrorMaker.GetStats()
        log.Printf("最终统计信息:")
        log.Printf("  消费消息数: %d", stats.MessagesConsumed)
        log.Printf("  生产消息数: %d", stats.MessagesProduced)
        log.Printf("  错误数: %d", stats.Errors)
        log.Printf("  运行时间: %v", time.Since(stats.StartTime))

        return nil</span>
}

</pre>
		
		<pre class="file" id="file1" style="display: none">package core

import (
        "fmt"
        "os"
        "time"

        "github.com/spf13/viper"
        
        "message-mirror/internal/pkg/security"
)

// Config 应用程序配置
type Config struct {
        Source      SourceConfig `mapstructure:"source"`
        Target      TargetConfig `mapstructure:"target"`
        Mirror      MirrorConfig `mapstructure:"mirror"`
        Producer    ProducerConfig `mapstructure:"producer"`
        Log         LogConfig `mapstructure:"log"`
        Server      ServerConfig `mapstructure:"server"`
        Retry       RetryConfig `mapstructure:"retry"`
        Dedup       DedupConfig `mapstructure:"dedup"`
        Security    SecurityConfig `mapstructure:"security"`
}

// SourceConfig 数据源配置（支持插件）
type SourceConfig struct {
        Type   string                 `mapstructure:"type"` // kafka, rabbitmq, file
        Config map[string]interface{} `mapstructure:",remain"` // 插件特定的配置
}

// TargetConfig 目标配置（目前只支持Kafka）
type TargetConfig struct {
        Brokers          []string `mapstructure:"brokers"`
        Topic            string   `mapstructure:"topic"`
        SecurityProtocol string   `mapstructure:"security_protocol"`
        SASLMechanism    string   `mapstructure:"sasl_mechanism"`
        SASLUsername     string   `mapstructure:"sasl_username"`
        SASLPassword     string   `mapstructure:"sasl_password"`
}

// KafkaConfig Kafka集群配置（保留用于向后兼容）
type KafkaConfig struct {
        Brokers          []string `mapstructure:"brokers"`
        Topic            string   `mapstructure:"topic"`
        Topics           []string `mapstructure:"topics"`
        SecurityProtocol string   `mapstructure:"security_protocol"`
        SASLMechanism    string   `mapstructure:"sasl_mechanism"`
        SASLUsername     string   `mapstructure:"sasl_username"`
        SASLPassword      string   `mapstructure:"sasl_password"`
}

// ConsumerConfig 消费者配置（保留用于向后兼容）
type ConsumerConfig struct {
        GroupID           string        `mapstructure:"group_id"`
        AutoOffsetReset   string        `mapstructure:"auto_offset_reset"`
        SessionTimeout    time.Duration `mapstructure:"session_timeout"`
        HeartbeatInterval time.Duration `mapstructure:"heartbeat_interval"`
        MaxProcessingTime time.Duration `mapstructure:"max_processing_time"`
        BatchSize         int           `mapstructure:"batch_size"`
}

// MirrorConfig 镜像配置
type MirrorConfig struct {
        Enabled           bool     `mapstructure:"enabled"`
        TopicPattern      string   `mapstructure:"topic_pattern"`
        ExcludeTopics     []string `mapstructure:"exclude_topics"`
        PreservePartition bool     `mapstructure:"preserve_partition"`
        OffsetSync        bool     `mapstructure:"offset_sync"`
        WorkerCount       int      `mapstructure:"worker_count"`
        // 流控配置
        ConsumerRateLimit  float64 `mapstructure:"consumer_rate_limit"`  // 消费速率限制（消息/秒，0表示不限制）
        ConsumerBurstSize  int     `mapstructure:"consumer_burst_size"`  // 消费突发大小
        ProducerRateLimit  float64 `mapstructure:"producer_rate_limit"`  // 生产速率限制（消息/秒，0表示不限制）
        ProducerBurstSize  int     `mapstructure:"producer_burst_size"`  // 生产突发大小
        BytesRateLimit     float64 `mapstructure:"bytes_rate_limit"`    // 字节速率限制（字节/秒，0表示不限制，优先于消息速率限制）
        BytesBurstSize     int     `mapstructure:"bytes_burst_size"`     // 字节突发大小
        // 批处理配置
        BatchEnabled       bool          `mapstructure:"batch_enabled"`        // 是否启用批处理
        BatchSize          int           `mapstructure:"batch_size"`           // 批处理大小（消息数）
        BatchTimeout       time.Duration `mapstructure:"batch_timeout"`        // 批处理超时时间
}

// ProducerConfig 生产者配置
type ProducerConfig struct {
        MaxMessageBytes    int           `mapstructure:"max_message_bytes"`
        CompressionType    string        `mapstructure:"compression_type"`
        RequiredAcks       int16         `mapstructure:"required_acks"`
        FlushFrequency    time.Duration `mapstructure:"flush_frequency"`
        RetryMax           int           `mapstructure:"retry_max"`
        Idempotent         bool          `mapstructure:"idempotent"`
}

// LogConfig 日志配置
type LogConfig struct {
        FilePath            string        `mapstructure:"file_path"`
        StatsInterval      time.Duration `mapstructure:"stats_interval"`
        RotateInterval     time.Duration `mapstructure:"rotate_interval"`     // 日志轮转间隔
        MaxArchiveFiles    int           `mapstructure:"max_archive_files"` // 保留的归档文件数量
        AsyncBufferSize    int           `mapstructure:"async_buffer_size"` // 异步缓冲区大小
}

// ServerConfig HTTP服务器配置
type ServerConfig struct {
        Enabled bool   `mapstructure:"enabled"`
        Address string `mapstructure:"address"` // HTTP服务器地址
}

// RetryConfig 重试配置
type RetryConfig struct {
        Enabled         bool          `mapstructure:"enabled"`
        MaxRetries      int           `mapstructure:"max_retries"`
        InitialInterval time.Duration `mapstructure:"initial_interval"`
        MaxInterval     time.Duration `mapstructure:"max_interval"`
        Multiplier      float64       `mapstructure:"multiplier"`
        Jitter          bool          `mapstructure:"jitter"`
}

// DedupConfig 去重配置
type DedupConfig struct {
        Enabled        bool          `mapstructure:"enabled"`
        Strategy       string        `mapstructure:"strategy"`        // 去重策略：key, value, key_value, hash
        TTL            time.Duration `mapstructure:"ttl"`             // 去重记录的TTL
        MaxEntries     int64         `mapstructure:"max_entries"`    // 最大去重记录数
        CleanupInterval time.Duration `mapstructure:"cleanup_interval"` // 清理过期记录的间隔
}

// SecurityConfig 安全配置
type SecurityConfig struct {
        TLS            security.TLSConfig `mapstructure:"tls"`
        AuditEnabled   bool      `mapstructure:"audit_enabled"`
        ConfigEncryption bool    `mapstructure:"config_encryption"`
        EncryptionKey  string    `mapstructure:"encryption_key"`
}

// LoadConfig 加载配置文件
func LoadConfig(configPath string) (*Config, error) <span class="cov8" title="1">{
        viper.SetConfigFile(configPath)
        viper.SetConfigType("yaml")

        // 设置默认值
        setDefaults()

        // 环境变量支持
        viper.AutomaticEnv()

        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(viper.ConfigFileNotFoundError); ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("配置文件未找到: %s", configPath)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("读取配置文件失败: %w", err)</span>
        }

        <span class="cov8" title="1">var config Config
        if err := viper.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("解析配置失败: %w", err)
        }</span>

        // 将source配置转换为map[string]interface{}格式供插件使用
        <span class="cov8" title="1">if config.Source.Config == nil </span><span class="cov0" title="0">{
                config.Source.Config = make(map[string]interface{})
                // 从viper中提取source配置（排除type字段）
                sourceConfig := viper.GetStringMap("source")
                for k, v := range sourceConfig </span><span class="cov0" title="0">{
                        if k != "type" </span><span class="cov0" title="0">{
                                config.Source.Config[k] = v
                        }</span>
                }
        }

        // 验证配置
        <span class="cov8" title="1">if err := validateConfig(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配置验证失败: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;config, nil</span>
}

// setDefaults 设置默认配置值
func setDefaults() <span class="cov8" title="1">{
        // Mirror配置默认值
        viper.SetDefault("mirror.enabled", true)
        viper.SetDefault("mirror.preserve_partition", true)
        viper.SetDefault("mirror.offset_sync", false)
        viper.SetDefault("mirror.worker_count", 4)
        // 流控默认值（0表示不限制）
        viper.SetDefault("mirror.consumer_rate_limit", 0.0)
        viper.SetDefault("mirror.consumer_burst_size", 100)
        viper.SetDefault("mirror.producer_rate_limit", 0.0)
        viper.SetDefault("mirror.producer_burst_size", 100)
        viper.SetDefault("mirror.bytes_rate_limit", 0.0)
        // 批处理默认值
        viper.SetDefault("mirror.batch_enabled", false)
        viper.SetDefault("mirror.batch_size", 100)
        viper.SetDefault("mirror.batch_timeout", 100*time.Millisecond)
        viper.SetDefault("mirror.bytes_burst_size", 10485760) // 10MB

        // Consumer配置默认值
        viper.SetDefault("consumer.group_id", "message-mirror-group")
        viper.SetDefault("consumer.auto_offset_reset", "earliest")
        viper.SetDefault("consumer.session_timeout", 30*time.Second)
        viper.SetDefault("consumer.heartbeat_interval", 3*time.Second)
        viper.SetDefault("consumer.max_processing_time", 5*time.Minute)
        viper.SetDefault("consumer.batch_size", 100)

        // Producer配置默认值
        viper.SetDefault("producer.max_message_bytes", 1000000)
        viper.SetDefault("producer.compression_type", "snappy")
        viper.SetDefault("producer.required_acks", 1)
        viper.SetDefault("producer.flush_frequency", 100*time.Millisecond)
        viper.SetDefault("producer.retry_max", 3)
        viper.SetDefault("producer.idempotent", true)

        // Log配置默认值
        viper.SetDefault("log.file_path", "message-mirror.log")
        viper.SetDefault("log.stats_interval", 10*time.Second)
        viper.SetDefault("log.rotate_interval", 24*time.Hour)
        viper.SetDefault("log.max_archive_files", 7)
        viper.SetDefault("log.async_buffer_size", 1000)

        // Server配置默认值
        viper.SetDefault("server.enabled", true)
        viper.SetDefault("server.address", ":8080")

        // Retry配置默认值
        viper.SetDefault("retry.enabled", true)
        viper.SetDefault("retry.max_retries", 3)
        viper.SetDefault("retry.initial_interval", 100*time.Millisecond)
        viper.SetDefault("retry.max_interval", 10*time.Second)
        viper.SetDefault("retry.multiplier", 2.0)
        viper.SetDefault("retry.jitter", true)

        // Dedup配置默认值
        viper.SetDefault("dedup.enabled", false)
        viper.SetDefault("dedup.strategy", "key_value")
        viper.SetDefault("dedup.ttl", 24*time.Hour)
        viper.SetDefault("dedup.max_entries", 1000000)
        viper.SetDefault("dedup.cleanup_interval", 1*time.Hour)

        // Security配置默认值
        viper.SetDefault("security.tls.enabled", false)
        viper.SetDefault("security.tls.insecure_skip_verify", false)
        viper.SetDefault("security.tls.min_version", "1.2")
        viper.SetDefault("security.audit_enabled", false)
        viper.SetDefault("security.config_encryption", false)
}</span>

// validateConfig 验证配置
func validateConfig(config *Config) error <span class="cov8" title="1">{
        // 验证数据源类型
        if config.Source.Type == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("数据源类型不能为空，支持的类型: kafka, rabbitmq, file")
        }</span>

        <span class="cov8" title="1">validTypes := map[string]bool{
                "kafka":    true,
                "rabbitmq": true,
                "file":     true,
        }
        if !validTypes[config.Source.Type] </span><span class="cov8" title="1">{
                return fmt.Errorf("不支持的数据源类型: %s，支持的类型: kafka, rabbitmq, file", config.Source.Type)
        }</span>

        // 验证目标集群
        <span class="cov8" title="1">if len(config.Target.Brokers) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("目标集群brokers不能为空")
        }</span>

        <span class="cov8" title="1">if config.Mirror.WorkerCount &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("worker数量必须大于0")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetConfigPath 获取配置文件路径
func GetConfigPath() string <span class="cov8" title="1">{
        if path := os.Getenv("CONFIG_PATH"); path != "" </span><span class="cov8" title="1">{
                return path
        }</span>
        <span class="cov8" title="1">return "config.yaml"</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package core

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "log"
        "sync"

        "gopkg.in/yaml.v3"
)

// ConfigManager 配置管理器，支持热重载
type ConfigManager struct {
        configPath string
        config     *Config
        mu         sync.RWMutex
        reloadChan chan *Config
        listeners  []ConfigReloadListener
}

// ConfigReloadListener 配置重载监听器
type ConfigReloadListener interface {
        OnConfigReload(oldConfig, newConfig *Config) error
}

// NewConfigManager 创建配置管理器
func NewConfigManager(configPath string) (*ConfigManager, error) <span class="cov0" title="0">{
        config, err := LoadConfig(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("加载配置失败: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;ConfigManager{
                configPath: configPath,
                config:     config,
                reloadChan: make(chan *Config, 1),
                listeners:  make([]ConfigReloadListener, 0),
        }, nil</span>
}

// GetConfig 获取当前配置（只读）
func (cm *ConfigManager) GetConfig() *Config <span class="cov0" title="0">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()
        return cm.config
}</span>

// UpdateConfig 更新配置（支持热重载）
func (cm *ConfigManager) UpdateConfig(newConfig *Config) error <span class="cov0" title="0">{
        // 验证配置
        if err := validateConfig(newConfig); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配置验证失败: %w", err)
        }</span>

        <span class="cov0" title="0">cm.mu.Lock()
        oldConfig := cm.config
        cm.config = newConfig
        cm.mu.Unlock()

        // 通知监听器
        for _, listener := range cm.listeners </span><span class="cov0" title="0">{
                if err := listener.OnConfigReload(oldConfig, newConfig); err != nil </span><span class="cov0" title="0">{
                        // 如果某个监听器失败，回滚配置
                        cm.mu.Lock()
                        cm.config = oldConfig
                        cm.mu.Unlock()
                        return fmt.Errorf("配置重载失败: %w", err)
                }</span>
        }

        // 保存到文件
        <span class="cov0" title="0">if err := cm.SaveConfigToFile(newConfig); err != nil </span><span class="cov0" title="0">{
                log.Printf("保存配置到文件失败: %v", err)
                // 不返回错误，因为配置已经在内存中更新
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateConfigFromJSON 从JSON更新配置
func (cm *ConfigManager) UpdateConfigFromJSON(jsonData []byte) error <span class="cov0" title="0">{
        var newConfig Config
        if err := json.Unmarshal(jsonData, &amp;newConfig); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("解析JSON配置失败: %w", err)
        }</span>

        <span class="cov0" title="0">return cm.UpdateConfig(&amp;newConfig)</span>
}

// SaveConfigToFile 保存配置到文件
func (cm *ConfigManager) SaveConfigToFile(config *Config) error <span class="cov0" title="0">{
        // 将配置转换为YAML
        yamlData, err := yaml.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("序列化配置失败: %w", err)
        }</span>

        // 写入文件
        <span class="cov0" title="0">if err := ioutil.WriteFile(cm.configPath, yamlData, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("写入配置文件失败: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ReloadFromFile 从文件重新加载配置
func (cm *ConfigManager) ReloadFromFile() error <span class="cov0" title="0">{
        newConfig, err := LoadConfig(cm.configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("重新加载配置失败: %w", err)
        }</span>

        <span class="cov0" title="0">return cm.UpdateConfig(newConfig)</span>
}

// RegisterListener 注册配置重载监听器
func (cm *ConfigManager) RegisterListener(listener ConfigReloadListener) <span class="cov0" title="0">{
        cm.mu.Lock()
        defer cm.mu.Unlock()
        cm.listeners = append(cm.listeners, listener)
}</span>

// WatchFile 监控配置文件变化（可选功能）
func (cm *ConfigManager) WatchFile() error <span class="cov0" title="0">{
        // 这里可以使用fsnotify实现文件监控
        // 为了简化，暂时不实现
        return nil
}</span>

// GetConfigJSON 获取配置的JSON表示
func (cm *ConfigManager) GetConfigJSON() ([]byte, error) <span class="cov0" title="0">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()
        return json.Marshal(cm.config)
}</span>

// GetConfigYAML 获取配置的YAML表示
func (cm *ConfigManager) GetConfigYAML() ([]byte, error) <span class="cov0" title="0">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()
        return yaml.Marshal(cm.config)
}</span>

</pre>
		
		<pre class="file" id="file3" style="display: none">package core

import (
        "os"
        "testing"
        "time"
)

func TestLoadConfig_WithSecurity(t *testing.T) <span class="cov0" title="0">{
        configContent := `
source:
  type: "kafka"
  brokers:
    - "localhost:9092"
  topic: "test-topic"

target:
  brokers:
    - "localhost:9093"

security:
  tls:
    enabled: true
    min_version: "1.2"
  audit_enabled: true
`
        
        tmpFile, err := os.CreateTemp("", "test-config-security-*.yaml")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("创建临时文件失败: %v", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(tmpFile.Name())
        
        tmpFile.WriteString(configContent)
        tmpFile.Close()
        
        config, err := LoadConfig(tmpFile.Name())
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("加载配置失败: %v", err)
        }</span>
        
        <span class="cov0" title="0">if !config.Security.TLS.Enabled </span><span class="cov0" title="0">{
                t.Error("期望security.tls.enabled=true")
        }</span>
        
        <span class="cov0" title="0">if config.Security.TLS.MinVersion != "1.2" </span><span class="cov0" title="0">{
                t.Errorf("期望security.tls.min_version='1.2'，实际'%s'", config.Security.TLS.MinVersion)
        }</span>
        
        <span class="cov0" title="0">if !config.Security.AuditEnabled </span><span class="cov0" title="0">{
                t.Error("期望security.audit_enabled=true")
        }</span>
}

func TestLoadConfig_WithDedup(t *testing.T) <span class="cov0" title="0">{
        configContent := `
source:
  type: "kafka"
  brokers:
    - "localhost:9092"
  topic: "test-topic"

target:
  brokers:
    - "localhost:9093"

dedup:
  enabled: true
  strategy: "hash"
  ttl: 12h
  max_entries: 500000
  cleanup_interval: 30m
`
        
        tmpFile, err := os.CreateTemp("", "test-config-dedup-*.yaml")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("创建临时文件失败: %v", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(tmpFile.Name())
        
        tmpFile.WriteString(configContent)
        tmpFile.Close()
        
        config, err := LoadConfig(tmpFile.Name())
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("加载配置失败: %v", err)
        }</span>
        
        <span class="cov0" title="0">if !config.Dedup.Enabled </span><span class="cov0" title="0">{
                t.Error("期望dedup.enabled=true")
        }</span>
        
        <span class="cov0" title="0">if config.Dedup.Strategy != "hash" </span><span class="cov0" title="0">{
                t.Errorf("期望dedup.strategy='hash'，实际'%s'", config.Dedup.Strategy)
        }</span>
        
        <span class="cov0" title="0">if config.Dedup.TTL != 12*time.Hour </span><span class="cov0" title="0">{
                t.Errorf("期望dedup.ttl=12h，实际%v", config.Dedup.TTL)
        }</span>
        
        <span class="cov0" title="0">if config.Dedup.MaxEntries != 500000 </span><span class="cov0" title="0">{
                t.Errorf("期望dedup.max_entries=500000，实际%d", config.Dedup.MaxEntries)
        }</span>
}

func TestLoadConfig_WithRetry(t *testing.T) <span class="cov0" title="0">{
        configContent := `
source:
  type: "kafka"
  brokers:
    - "localhost:9092"
  topic: "test-topic"

target:
  brokers:
    - "localhost:9093"

retry:
  enabled: true
  max_retries: 5
  initial_interval: 200ms
  max_interval: 20s
  multiplier: 3.0
  jitter: false
`
        
        tmpFile, err := os.CreateTemp("", "test-config-retry-*.yaml")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("创建临时文件失败: %v", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(tmpFile.Name())
        
        tmpFile.WriteString(configContent)
        tmpFile.Close()
        
        config, err := LoadConfig(tmpFile.Name())
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("加载配置失败: %v", err)
        }</span>
        
        <span class="cov0" title="0">if !config.Retry.Enabled </span><span class="cov0" title="0">{
                t.Error("期望retry.enabled=true")
        }</span>
        
        <span class="cov0" title="0">if config.Retry.MaxRetries != 5 </span><span class="cov0" title="0">{
                t.Errorf("期望retry.max_retries=5，实际%d", config.Retry.MaxRetries)
        }</span>
        
        <span class="cov0" title="0">if config.Retry.InitialInterval != 200*time.Millisecond </span><span class="cov0" title="0">{
                t.Errorf("期望retry.initial_interval=200ms，实际%v", config.Retry.InitialInterval)
        }</span>
        
        <span class="cov0" title="0">if config.Retry.Multiplier != 3.0 </span><span class="cov0" title="0">{
                t.Errorf("期望retry.multiplier=3.0，实际%f", config.Retry.Multiplier)
        }</span>
        
        <span class="cov0" title="0">if config.Retry.Jitter </span><span class="cov0" title="0">{
                t.Error("期望retry.jitter=false")
        }</span>
}

func TestValidateConfig_EdgeCases(t *testing.T) <span class="cov0" title="0">{
        tests := []struct {
                name    string
                config  *Config
                wantErr bool
        }{
                {
                        name: "worker_count为负数",
                        config: &amp;Config{
                                Source: SourceConfig{Type: "kafka"},
                                Target: TargetConfig{Brokers: []string{"localhost:9092"}},
                                Mirror: MirrorConfig{WorkerCount: -1},
                        },
                        wantErr: true,
                },
                {
                        name: "worker_count为0",
                        config: &amp;Config{
                                Source: SourceConfig{Type: "kafka"},
                                Target: TargetConfig{Brokers: []string{"localhost:9092"}},
                                Mirror: MirrorConfig{WorkerCount: 0},
                        },
                        wantErr: true,
                },
                {
                        name: "worker_count为1（最小值）",
                        config: &amp;Config{
                                Source: SourceConfig{Type: "kafka"},
                                Target: TargetConfig{Brokers: []string{"localhost:9092"}},
                                Mirror: MirrorConfig{WorkerCount: 1},
                        },
                        wantErr: false,
                },
        }
        
        for _, tt := range tests </span><span class="cov0" title="0">{
                t.Run(tt.name, func(t *testing.T) </span><span class="cov0" title="0">{
                        err := validateConfig(tt.config)
                        if (err != nil) != tt.wantErr </span><span class="cov0" title="0">{
                                t.Errorf("validateConfig() error = %v, wantErr %v", err, tt.wantErr)
                        }</span>
                })
        }
}

</pre>
		
		<pre class="file" id="file4" style="display: none">package core

import (
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "log"
        "net/http"
        "sync"
        "time"

        "github.com/prometheus/client_golang/prometheus/promhttp"

        "message-mirror/internal/pkg/metrics"
        "message-mirror/web"
)

// HTTPServer HTTP服务器（提供健康检查和指标）
type HTTPServer struct {
        server        *http.Server
        metrics       *metrics.Metrics
        mirror        *MirrorMaker
        configManager *ConfigManager
        ctx           context.Context
        cancel        context.CancelFunc
        wg            sync.WaitGroup
}

// NewHTTPServer 创建新的HTTP服务器
func NewHTTPServer(addr string, metricsInstance *metrics.Metrics, mirror *MirrorMaker, configManager *ConfigManager, ctx context.Context) *HTTPServer <span class="cov0" title="0">{
        serverCtx, cancel := context.WithCancel(ctx)

        mux := http.NewServeMux()
        server := &amp;http.Server{
                Addr:    addr,
                Handler: mux,
        }

        httpServer := &amp;HTTPServer{
                server:        server,
                metrics:       metricsInstance,
                mirror:        mirror,
                configManager: configManager,
                ctx:           serverCtx,
                cancel:        cancel,
        }

        // 注册路由
        mux.HandleFunc("/health", httpServer.healthHandler)
        mux.HandleFunc("/ready", httpServer.readyHandler)
        mux.Handle("/metrics", promhttp.Handler())
        
        // 配置API
        mux.HandleFunc("/api/config", httpServer.configHandler)
        mux.HandleFunc("/api/config/reload", httpServer.configReloadHandler)
        mux.HandleFunc("/api/stats", httpServer.statsHandler)
        
        // Web UI静态文件
        mux.HandleFunc("/", httpServer.webUIHandler)
        mux.HandleFunc("/ui", httpServer.webUIHandler)

        return httpServer
}</span>

// Start 启动HTTP服务器
func (s *HTTPServer) Start() error <span class="cov0" title="0">{
        s.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer s.wg.Done()

                // 启动速率更新goroutine
                ticker := time.NewTicker(5 * time.Second)
                defer ticker.Stop()

                go func() </span><span class="cov0" title="0">{
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-s.ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                case &lt;-ticker.C:<span class="cov0" title="0">
                                        if s.metrics != nil </span><span class="cov0" title="0">{
                                                s.metrics.UpdateRates()
                                        }</span>
                                }
                        }
                }()

                // 启动HTTP服务器
                <span class="cov0" title="0">if err := s.server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Printf("HTTP服务器错误: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">log.Printf("HTTP服务器已启动，监听地址: %s", s.server.Addr)
        return nil</span>
}

// Stop 停止HTTP服务器
func (s *HTTPServer) Stop() error <span class="cov0" title="0">{
        s.cancel()
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := s.server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.wg.Wait()
        log.Println("HTTP服务器已停止")
        return nil</span>
}

// healthHandler 健康检查处理器
func (s *HTTPServer) healthHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // 检查基本状态
        healthy := true
        status := "healthy"

        if s.mirror == nil </span><span class="cov0" title="0">{
                healthy = false
                status = "unhealthy"
        }</span> else<span class="cov0" title="0"> {
                // 可以添加更多健康检查逻辑
                stats := s.mirror.GetStats()
                // 如果最近没有消息处理且运行时间超过1分钟，可能是异常
                if time.Since(stats.LastMessageTime) &gt; 5*time.Minute &amp;&amp; time.Since(stats.StartTime) &gt; 1*time.Minute </span><span class="cov0" title="0">{
                        healthy = false
                        status = "degraded"
                }</span>
        }

        <span class="cov0" title="0">if s.metrics != nil </span><span class="cov0" title="0">{
                s.metrics.SetHealthStatus(healthy)
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if healthy </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                w.Write([]byte(`{"status":"` + status + `"}`))
        }</span> else<span class="cov0" title="0"> {
                w.WriteHeader(http.StatusServiceUnavailable)
                w.Write([]byte(`{"status":"` + status + `"}`))
        }</span>
}

// readyHandler 就绪检查处理器
func (s *HTTPServer) readyHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ready := s.mirror != nil

        w.Header().Set("Content-Type", "application/json")
        if ready </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                w.Write([]byte(`{"status":"ready"}`))
        }</span> else<span class="cov0" title="0"> {
                w.WriteHeader(http.StatusServiceUnavailable)
                w.Write([]byte(`{"status":"not ready"}`))
        }</span>
}

// configHandler 配置处理器
func (s *HTTPServer) configHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type")

        if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                return
        }</span>

        <span class="cov0" title="0">if s.configManager == nil </span><span class="cov0" title="0">{
                http.Error(w, `{"error":"配置管理器未初始化"}`, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">switch r.Method </span>{
        case "GET":<span class="cov0" title="0">
                // 获取配置
                configJSON, err := s.configManager.GetConfigJSON()
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, fmt.Sprintf(`{"error":"获取配置失败: %v"}`, err), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
                w.Write(configJSON)</span>

        case "POST", "PUT":<span class="cov0" title="0">
                // 更新配置
                body, err := ioutil.ReadAll(r.Body)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, fmt.Sprintf(`{"error":"读取请求体失败: %v"}`, err), http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">if err := s.configManager.UpdateConfigFromJSON(body); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, fmt.Sprintf(`{"error":"更新配置失败: %v"}`, err), http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
                w.Write([]byte(`{"status":"success","message":"配置已更新"}`))</span>

        default:<span class="cov0" title="0">
                http.Error(w, `{"error":"不支持的HTTP方法"}`, http.StatusMethodNotAllowed)</span>
        }
}

// configReloadHandler 配置重载处理器
func (s *HTTPServer) configReloadHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Access-Control-Allow-Origin", "*")

        if s.configManager == nil </span><span class="cov0" title="0">{
                http.Error(w, `{"error":"配置管理器未初始化"}`, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if r.Method != "POST" </span><span class="cov0" title="0">{
                http.Error(w, `{"error":"只支持POST方法"}`, http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">if err := s.configManager.ReloadFromFile(); err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf(`{"error":"重载配置失败: %v"}`, err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{"status":"success","message":"配置已重载"}`))</span>
}

// statsHandler 统计信息处理器
func (s *HTTPServer) statsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Access-Control-Allow-Origin", "*")

        if s.mirror == nil </span><span class="cov0" title="0">{
                http.Error(w, `{"error":"MirrorMaker未初始化"}`, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">stats := s.mirror.GetStats()
        response := map[string]interface{}{
                "messages_consumed": stats.MessagesConsumed,
                "messages_produced": stats.MessagesProduced,
                "bytes_consumed":    stats.BytesConsumed,
                "bytes_produced":    stats.BytesProduced,
                "errors":            stats.Errors,
                "last_message_time": stats.LastMessageTime.Format(time.RFC3339),
                "start_time":        stats.StartTime.Format(time.RFC3339),
                "uptime_seconds":    time.Since(stats.StartTime).Seconds(),
        }

        jsonData, err := json.Marshal(response)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf(`{"error":"序列化统计信息失败: %v"}`, err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        w.Write(jsonData)</span>
}

// webUIHandler Web UI处理器
func (s *HTTPServer) webUIHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(web.GetWebUIHTML()))
}</span>

</pre>
		
		<pre class="file" id="file5" style="display: none">package core

import (
        "context"
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/IBM/sarama"
        
        "message-mirror/internal/pkg/logger"
        "message-mirror/internal/pkg/ratelimiter"
        "message-mirror/internal/pkg/retry"
        "message-mirror/internal/pkg/deduplicator"
        "message-mirror/internal/pkg/optimization"
        "message-mirror/internal/pkg/metrics"
        "message-mirror/internal/plugins"
)

// MirrorMaker 消息镜像器
type MirrorMaker struct {
        config          *Config
        source          plugins.SourcePlugin
        producer        *MirrorProducer
        logger          *logger.Logger
        metrics         *metrics.Metrics
        retryManager    *retry.RetryManager
        deduplicator    *deduplicator.Deduplicator
        batchProcessor  *optimization.BatchProcessor  // 批处理器（如果启用）
        ctx             context.Context
        cancel          context.CancelFunc
        wg              sync.WaitGroup
        stats           *Stats
        errorChan       chan error
        consumerLimiter *ratelimiter.RateLimiter  // 消费速率限制器（按消息）
        producerLimiter *ratelimiter.RateLimiter  // 生产速率限制器（按消息）
        bytesLimiter    *ratelimiter.RateLimiter  // 字节速率限制器（按字节，优先使用）
        mu              sync.RWMutex   // 保护配置更新
}

// Stats 统计信息
type Stats struct {
        mu                sync.RWMutex
        MessagesConsumed  int64
        MessagesProduced  int64
        BytesConsumed     int64
        BytesProduced     int64
        Errors            int64
        LastMessageTime   time.Time
        StartTime         time.Time
}

// NewMirrorMaker 创建新的MirrorMaker实例
func NewMirrorMaker(config *Config) (*MirrorMaker, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())

        // 创建数据源插件
        source, err := plugins.CreatePlugin(config.Source.Type)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("创建数据源插件失败: %w", err)
        }</span>

        // 初始化插件
        <span class="cov8" title="1">if err := source.Initialize(config.Source.Config); err != nil </span><span class="cov8" title="1">{
                cancel()
                return nil, fmt.Errorf("初始化数据源插件失败: %w", err)
        }</span>

        // 创建生产者
        <span class="cov0" title="0">producer, err := NewMirrorProducer(config)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("创建生产者失败: %w", err)
        }</span>

        <span class="cov0" title="0">stats := &amp;Stats{
                StartTime: time.Now(),
        }

        // 创建日志管理器
        logConfig := &amp;logger.LogConfig{
                FilePath:         config.Log.FilePath,
                StatsInterval:    config.Log.StatsInterval,
                RotateInterval:   config.Log.RotateInterval,
                MaxArchiveFiles:  config.Log.MaxArchiveFiles,
                AsyncBufferSize:  config.Log.AsyncBufferSize,
        }
        loggerInstance, err := logger.NewLogger(logConfig, ctx)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("创建日志管理器失败: %w", err)
        }</span>

        // 创建速率限制器
        <span class="cov0" title="0">var consumerLimiter, producerLimiter, bytesLimiter *ratelimiter.RateLimiter

        // 字节速率限制器（优先使用）
        if config.Mirror.BytesRateLimit &gt; 0 </span><span class="cov0" title="0">{
                burstSize := config.Mirror.BytesBurstSize
                if burstSize &lt;= 0 </span><span class="cov0" title="0">{
                        burstSize = 10485760 // 默认10MB
                }</span>
                <span class="cov0" title="0">bytesLimiter = ratelimiter.NewBytesRateLimiter(config.Mirror.BytesRateLimit, burstSize)</span>
        } else<span class="cov0" title="0"> {
                // 如果没有字节限制，使用消息限制
                if config.Mirror.ConsumerRateLimit &gt; 0 </span><span class="cov0" title="0">{
                        burstSize := config.Mirror.ConsumerBurstSize
                        if burstSize &lt;= 0 </span><span class="cov0" title="0">{
                                burstSize = 100
                        }</span>
                        <span class="cov0" title="0">consumerLimiter = ratelimiter.NewRateLimiter(config.Mirror.ConsumerRateLimit, burstSize, true)</span>
                }

                <span class="cov0" title="0">if config.Mirror.ProducerRateLimit &gt; 0 </span><span class="cov0" title="0">{
                        burstSize := config.Mirror.ProducerBurstSize
                        if burstSize &lt;= 0 </span><span class="cov0" title="0">{
                                burstSize = 100
                        }</span>
                        <span class="cov0" title="0">producerLimiter = ratelimiter.NewRateLimiter(config.Mirror.ProducerRateLimit, burstSize, true)</span>
                }
        }

        // 创建指标管理器
        <span class="cov0" title="0">metricsInstance := metrics.NewMetrics()
        metricsInstance.Register()

        // 创建重试管理器
        var retryManager *retry.RetryManager
        if config.Retry.Enabled </span><span class="cov0" title="0">{
                retryConfig := &amp;retry.RetryConfigInternal{
                        MaxRetries:      config.Retry.MaxRetries,
                        InitialInterval: config.Retry.InitialInterval,
                        MaxInterval:     config.Retry.MaxInterval,
                        Multiplier:      config.Retry.Multiplier,
                        Jitter:          config.Retry.Jitter,
                }
                if retryConfig.MaxRetries == 0 </span><span class="cov0" title="0">{
                        retryConfig = retry.DefaultRetryConfig()
                }</span>
                <span class="cov0" title="0">retryManager = retry.NewRetryManager(retryConfig)</span>
        }

        // 创建去重器
        <span class="cov0" title="0">dedupConfig := &amp;deduplicator.DedupConfig{
                Enabled:        config.Dedup.Enabled,
                Strategy:       config.Dedup.Strategy,
                TTL:            config.Dedup.TTL,
                MaxEntries:     config.Dedup.MaxEntries,
                CleanupInterval: config.Dedup.CleanupInterval,
        }
        deduplicatorInstance := deduplicator.NewDeduplicator(dedupConfig, ctx)

        mm := &amp;MirrorMaker{
                config:          config,
                source:          source,
                producer:        producer,
                logger:          loggerInstance,
                metrics:         metricsInstance,
                retryManager:    retryManager,
                deduplicator:    deduplicatorInstance,
                batchProcessor:  nil, // 稍后初始化
                ctx:             ctx,
                cancel:          cancel,
                stats:           stats,
                errorChan:       make(chan error, 100),
                consumerLimiter: consumerLimiter,
                producerLimiter: producerLimiter,
                bytesLimiter:    bytesLimiter,
        }
        
        // 如果启用批处理，创建批处理器（需要mm实例）
        if config.Mirror.BatchEnabled &amp;&amp; config.Mirror.BatchSize &gt; 0 </span><span class="cov0" title="0">{
                batchSize := config.Mirror.BatchSize
                batchTimeout := config.Mirror.BatchTimeout
                if batchTimeout &lt;= 0 </span><span class="cov0" title="0">{
                        batchTimeout = 100 * time.Millisecond
                }</span>
                
                // 批处理函数：批量发送消息
                <span class="cov0" title="0">processor := func(batch []*optimization.Message) error </span><span class="cov0" title="0">{
                        for _, optMsg := range batch </span><span class="cov0" title="0">{
                                // 将optimization.Message转换为plugins.Message
                                msg := &amp;plugins.Message{
                                        Key:       optMsg.Key,
                                        Value:     optMsg.Value,
                                        Headers:   optMsg.Headers,
                                        Timestamp: optMsg.Timestamp,
                                        Source:    optMsg.Source,
                                        Metadata:  optMsg.Metadata,
                                }
                                if err := mm.processMessage(msg); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }
                
                <span class="cov0" title="0">mm.batchProcessor = optimization.NewBatchProcessor(batchSize, batchTimeout, processor)</span>
        }
        
        <span class="cov0" title="0">return mm, nil</span>
}

// Start 启动镜像服务
func (mm *MirrorMaker) Start() error <span class="cov0" title="0">{
        log.Println("启动MirrorMaker...")

        // 启动统计信息打印
        mm.wg.Add(1)
        go mm.printStats()

        // 启动错误处理
        mm.wg.Add(1)
        go mm.handleErrors()

        // 启动数据源插件
        if err := mm.source.Start(mm.ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("启动数据源插件失败: %w", err)
        }</span>

        // 启动生产者
        <span class="cov0" title="0">if err := mm.producer.Start(mm.ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("启动生产者失败: %w", err)
        }</span>

        // 启动批处理器（如果启用）
        <span class="cov0" title="0">if mm.batchProcessor != nil </span><span class="cov0" title="0">{
                mm.batchProcessor.Start(mm.ctx)
                log.Println("批处理器已启动")
        }</span>

        // 启动worker goroutines
        <span class="cov0" title="0">for i := 0; i &lt; mm.config.Mirror.WorkerCount; i++ </span><span class="cov0" title="0">{
                mm.wg.Add(1)
                go mm.worker(i)
        }</span>

        <span class="cov0" title="0">log.Printf("MirrorMaker已启动，使用 %d 个worker", mm.config.Mirror.WorkerCount)
        return nil</span>
}

// worker 工作协程，处理消息镜像
func (mm *MirrorMaker) worker(id int) <span class="cov0" title="0">{
        defer mm.wg.Done()

        log.Printf("Worker %d 启动", id)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-mm.ctx.Done():<span class="cov0" title="0">
                        log.Printf("Worker %d 停止", id)
                        return</span>

                case msg, ok := &lt;-mm.source.Messages():<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                log.Printf("Worker %d: 消息通道已关闭", id)
                                return
                        }</span>

                        // 应用消费速率限制
                        <span class="cov0" title="0">if err := mm.applyConsumerRateLimit(msg); err != nil </span><span class="cov0" title="0">{
                                if err == mm.ctx.Err() </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">log.Printf("Worker %d: 应用消费速率限制失败: %v", id, err)
                                continue</span>
                        }

                        // 如果启用批处理，将消息添加到批处理器
                        <span class="cov0" title="0">if mm.batchProcessor != nil </span><span class="cov0" title="0">{
                                // 将plugin.Message转换为optimization.Message
                                optMsg := &amp;optimization.Message{
                                        Key:       msg.Key,
                                        Value:     msg.Value,
                                        Headers:   msg.Headers,
                                        Timestamp: msg.Timestamp,
                                        Source:    msg.Source,
                                        Metadata:  msg.Metadata,
                                }
                                if err := mm.batchProcessor.Add(optMsg); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Worker %d: 添加消息到批处理器失败: %v", id, err)
                                        mm.stats.mu.Lock()
                                        mm.stats.Errors++
                                        mm.stats.mu.Unlock()
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // 否则直接处理单条消息
                                if err := mm.processMessage(msg); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Worker %d: 处理消息失败: %v", id, err)
                                        mm.stats.mu.Lock()
                                        mm.stats.Errors++
                                        mm.stats.mu.Unlock()
                                        mm.errorChan &lt;- fmt.Errorf("worker %d: %w", id, err)
                                }</span>
                        }
                }
        }
}

// applyConsumerRateLimit 应用消费速率限制
func (mm *MirrorMaker) applyConsumerRateLimit(msg *plugins.Message) error <span class="cov0" title="0">{
        // 优先使用字节速率限制器
        if mm.bytesLimiter != nil </span><span class="cov0" title="0">{
                return mm.bytesLimiter.WaitBytes(mm.ctx, len(msg.Value)+len(msg.Key))
        }</span>

        // 使用消息速率限制器
        <span class="cov0" title="0">if mm.consumerLimiter != nil </span><span class="cov0" title="0">{
                return mm.consumerLimiter.Wait(mm.ctx)
        }</span>

        <span class="cov0" title="0">return nil</span>
}


// processMessage 处理单条消息
func (mm *MirrorMaker) processMessage(msg *plugins.Message) error <span class="cov0" title="0">{
        startTime := time.Now()

        // 检查消息是否重复（去重）
        if mm.deduplicator != nil </span><span class="cov0" title="0">{
                // 将plugin.Message转换为deduplicator.Message
                dedupMsg := &amp;deduplicator.Message{
                        Key:       msg.Key,
                        Value:     msg.Value,
                        Headers:   msg.Headers,
                        Timestamp: msg.Timestamp,
                        Source:    msg.Source,
                        Metadata:  msg.Metadata,
                }
                isDuplicate, err := mm.deduplicator.IsDuplicate(dedupMsg)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("去重检查失败: %v", err)
                        // 去重检查失败不影响消息处理，继续处理
                }</span> else<span class="cov0" title="0"> if isDuplicate </span><span class="cov0" title="0">{
                        // 消息重复，跳过处理
                        log.Printf("消息重复，已跳过: key=%s", string(msg.Key))
                        // 仍然更新消费统计（因为确实消费了消息）
                        mm.stats.mu.Lock()
                        mm.stats.MessagesConsumed++
                        mm.stats.BytesConsumed += int64(len(msg.Value))
                        mm.stats.LastMessageTime = time.Now()
                        mm.stats.mu.Unlock()

                        if mm.metrics != nil </span><span class="cov0" title="0">{
                                mm.metrics.RecordMessageConsumed(len(msg.Value) + len(msg.Key))
                        }</span>

                        // 确认消息已处理（即使是重复的）
                        <span class="cov0" title="0">if err := mm.source.Ack(msg); err != nil </span><span class="cov0" title="0">{
                                log.Printf("确认重复消息失败: %v", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }

        // 更新统计信息
        <span class="cov0" title="0">mm.stats.mu.Lock()
        mm.stats.MessagesConsumed++
        mm.stats.BytesConsumed += int64(len(msg.Value))
        mm.stats.LastMessageTime = time.Now()
        mm.stats.mu.Unlock()

        // 记录消费指标
        if mm.metrics != nil </span><span class="cov0" title="0">{
                mm.metrics.RecordMessageConsumed(len(msg.Value) + len(msg.Key))
        }</span>

        // 确定目标topic
        <span class="cov0" title="0">targetTopic := mm.getTargetTopic(msg)

        // 创建要发送的消息
        producerMessage := &amp;sarama.ProducerMessage{
                Topic:     targetTopic,
                Key:       sarama.ByteEncoder(msg.Key),
                Value:     sarama.ByteEncoder(msg.Value),
                Headers:   mm.convertHeaders(msg.Headers),
                Timestamp: msg.Timestamp,
        }

        // 如果配置了保留分区且消息来自Kafka，则设置分区
        if mm.config.Mirror.PreservePartition &amp;&amp; msg.Source == "kafka" </span><span class="cov0" title="0">{
                if partition, ok := msg.Metadata["partition"].(int32); ok </span><span class="cov0" title="0">{
                        producerMessage.Partition = partition
                }</span>
        }

        // 应用生产速率限制
        <span class="cov0" title="0">if err := mm.applyProducerRateLimit(msg); err != nil </span><span class="cov0" title="0">{
                if err == mm.ctx.Err() </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("应用生产速率限制失败: %w", err)</span>
        }

        // 发送消息到目标集群（带重试）
        <span class="cov0" title="0">var sendErr error
        if mm.retryManager != nil &amp;&amp; mm.config.Retry.Enabled </span><span class="cov0" title="0">{
                sendErr = mm.retryManager.Retry(mm.ctx, func() error </span><span class="cov0" title="0">{
                        return mm.producer.Send(producerMessage)
                }</span>)
        } else<span class="cov0" title="0"> {
                sendErr = mm.producer.Send(producerMessage)
        }</span>

        <span class="cov0" title="0">if sendErr != nil </span><span class="cov0" title="0">{
                // 记录失败指标
                if mm.metrics != nil </span><span class="cov0" title="0">{
                        mm.metrics.RecordMessageFailed()
                }</span>
                <span class="cov0" title="0">mm.stats.mu.Lock()
                mm.stats.Errors++
                mm.stats.mu.Unlock()
                return fmt.Errorf("发送消息失败 (topic=%s): %w", targetTopic, sendErr)</span>
        }

        // 更新生产统计
        <span class="cov0" title="0">mm.stats.mu.Lock()
        mm.stats.MessagesProduced++
        mm.stats.BytesProduced += int64(len(msg.Value))
        mm.stats.mu.Unlock()

        // 记录生产指标和延迟
        if mm.metrics != nil </span><span class="cov0" title="0">{
                mm.metrics.RecordMessageProduced(len(msg.Value) + len(msg.Key))
                latency := time.Since(startTime)
                mm.metrics.RecordLatency(latency)
        }</span>

        // 确认消息已处理
        <span class="cov0" title="0">if err := mm.source.Ack(msg); err != nil </span><span class="cov0" title="0">{
                log.Printf("确认消息失败: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// applyProducerRateLimit 应用生产速率限制
func (mm *MirrorMaker) applyProducerRateLimit(msg *plugins.Message) error <span class="cov0" title="0">{
        // 优先使用字节速率限制器
        if mm.bytesLimiter != nil </span><span class="cov0" title="0">{
                return mm.bytesLimiter.WaitBytes(mm.ctx, len(msg.Value)+len(msg.Key))
        }</span>

        // 使用消息速率限制器
        <span class="cov0" title="0">if mm.producerLimiter != nil </span><span class="cov0" title="0">{
                return mm.producerLimiter.Wait(mm.ctx)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getTargetTopic 获取目标topic名称
func (mm *MirrorMaker) getTargetTopic(msg *plugins.Message) string <span class="cov0" title="0">{
        // 如果配置了目标topic，直接使用
        if mm.config.Target.Topic != "" </span><span class="cov0" title="0">{
                return mm.config.Target.Topic
        }</span>

        // 如果消息来自Kafka，尝试从metadata获取topic
        <span class="cov0" title="0">if msg.Source == "kafka" </span><span class="cov0" title="0">{
                if topic, ok := msg.Metadata["topic"].(string); ok </span><span class="cov0" title="0">{
                        return topic
                }</span>
        }

        // 否则使用默认topic名称
        <span class="cov0" title="0">return "mirrored-messages"</span>
}

// convertHeaders 转换消息头
func (mm *MirrorMaker) convertHeaders(headers map[string][]byte) []sarama.RecordHeader <span class="cov0" title="0">{
        if len(headers) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make([]sarama.RecordHeader, 0, len(headers))
        for k, v := range headers </span><span class="cov0" title="0">{
                result = append(result, sarama.RecordHeader{
                        Key:   []byte(k),
                        Value: v,
                })
        }</span>

        <span class="cov0" title="0">return result</span>
}

// Stop 停止镜像服务
func (mm *MirrorMaker) Stop() error <span class="cov0" title="0">{
        log.Println("正在停止MirrorMaker...")

        // 取消上下文
        mm.cancel()

        // 停止批处理器（如果启用）
        if mm.batchProcessor != nil </span><span class="cov0" title="0">{
                mm.batchProcessor.Stop()
                log.Println("批处理器已停止")
        }</span>

        // 停止数据源插件
        <span class="cov0" title="0">if err := mm.source.Stop(); err != nil </span><span class="cov0" title="0">{
                log.Printf("停止数据源插件失败: %v", err)
        }</span>

        // 停止生产者
        <span class="cov0" title="0">if err := mm.producer.Stop(); err != nil </span><span class="cov0" title="0">{
                log.Printf("停止生产者失败: %v", err)
        }</span>

        // 等待所有goroutine完成
        <span class="cov0" title="0">mm.wg.Wait()

        // 停止日志管理器
        if mm.logger != nil </span><span class="cov0" title="0">{
                if err := mm.logger.Stop(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("停止日志管理器失败: %v", err)
                }</span>
        }

        // 停止去重器
        <span class="cov0" title="0">if mm.deduplicator != nil </span><span class="cov0" title="0">{
                mm.deduplicator.Stop()
        }</span>

        <span class="cov0" title="0">log.Println("MirrorMaker已停止")
        return nil</span>
}

// GetMetrics 获取指标管理器
func (mm *MirrorMaker) GetMetrics() *metrics.Metrics <span class="cov0" title="0">{
        return mm.metrics
}</span>

// OnConfigReload 实现ConfigReloadListener接口，处理配置热重载
func (mm *MirrorMaker) OnConfigReload(oldConfig, newConfig *Config) error <span class="cov0" title="0">{
        mm.mu.Lock()
        defer mm.mu.Unlock()

        log.Println("开始配置热重载...")

        // 更新配置
        mm.config = newConfig

        // 更新速率限制器
        if newConfig.Mirror.BytesRateLimit &gt; 0 </span><span class="cov0" title="0">{
                burstSize := newConfig.Mirror.BytesBurstSize
                if burstSize &lt;= 0 </span><span class="cov0" title="0">{
                        burstSize = 10485760 // 默认10MB
                }</span>
                <span class="cov0" title="0">mm.bytesLimiter = ratelimiter.NewBytesRateLimiter(newConfig.Mirror.BytesRateLimit, burstSize)
                mm.consumerLimiter = nil
                mm.producerLimiter = nil</span>
        } else<span class="cov0" title="0"> {
                mm.bytesLimiter = nil
                if newConfig.Mirror.ConsumerRateLimit &gt; 0 </span><span class="cov0" title="0">{
                        burstSize := newConfig.Mirror.ConsumerBurstSize
                        if burstSize &lt;= 0 </span><span class="cov0" title="0">{
                                burstSize = 100
                        }</span>
                        <span class="cov0" title="0">mm.consumerLimiter = ratelimiter.NewRateLimiter(newConfig.Mirror.ConsumerRateLimit, burstSize, true)</span>
                }
                <span class="cov0" title="0">if newConfig.Mirror.ProducerRateLimit &gt; 0 </span><span class="cov0" title="0">{
                        burstSize := newConfig.Mirror.ProducerBurstSize
                        if burstSize &lt;= 0 </span><span class="cov0" title="0">{
                                burstSize = 100
                        }</span>
                        <span class="cov0" title="0">mm.producerLimiter = ratelimiter.NewRateLimiter(newConfig.Mirror.ProducerRateLimit, burstSize, true)</span>
                }
        }

        // 更新批处理器
        <span class="cov0" title="0">if newConfig.Mirror.BatchEnabled </span><span class="cov0" title="0">{
                if mm.batchProcessor == nil </span><span class="cov0" title="0">{
                // 创建新的批处理器
                processor := func(batch []*optimization.Message) error </span><span class="cov0" title="0">{
                        for _, optMsg := range batch </span><span class="cov0" title="0">{
                                // 将optimization.Message转换为plugins.Message
                                msg := &amp;plugins.Message{
                                        Key:       optMsg.Key,
                                        Value:     optMsg.Value,
                                        Headers:   optMsg.Headers,
                                        Timestamp: optMsg.Timestamp,
                                        Source:    optMsg.Source,
                                        Metadata:  optMsg.Metadata,
                                }
                                if err := mm.processMessage(msg); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("批处理中处理消息失败: %v", err)
                                        // 继续处理其他消息
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">mm.batchProcessor = optimization.NewBatchProcessor(newConfig.Mirror.BatchSize, newConfig.Mirror.BatchTimeout, processor)
                        mm.batchProcessor.Start(mm.ctx)</span>
                } else<span class="cov0" title="0"> {
                        // 更新现有批处理器的配置
                        mm.batchProcessor.UpdateConfig(newConfig.Mirror.BatchSize, newConfig.Mirror.BatchTimeout)
                }</span>
        } else<span class="cov0" title="0"> {
                if mm.batchProcessor != nil </span><span class="cov0" title="0">{
                        mm.batchProcessor.Stop()
                        mm.batchProcessor = nil
                }</span>
        }

        // 更新重试管理器
        <span class="cov0" title="0">if newConfig.Retry.Enabled </span><span class="cov0" title="0">{
                retryConfig := &amp;retry.RetryConfigInternal{
                        MaxRetries:      newConfig.Retry.MaxRetries,
                        InitialInterval: newConfig.Retry.InitialInterval,
                        MaxInterval:     newConfig.Retry.MaxInterval,
                        Multiplier:      newConfig.Retry.Multiplier,
                        Jitter:          newConfig.Retry.Jitter,
                }
                if retryConfig.MaxRetries == 0 </span><span class="cov0" title="0">{
                        retryConfig = retry.DefaultRetryConfig()
                }</span>
                <span class="cov0" title="0">mm.retryManager = retry.NewRetryManager(retryConfig)</span>
        } else<span class="cov0" title="0"> {
                mm.retryManager = nil
        }</span>

        // 更新去重器配置
        <span class="cov0" title="0">if mm.deduplicator != nil </span><span class="cov0" title="0">{
                dedupConfig := &amp;deduplicator.DedupConfig{
                        Enabled:        newConfig.Dedup.Enabled,
                        Strategy:       newConfig.Dedup.Strategy,
                        TTL:            newConfig.Dedup.TTL,
                        MaxEntries:     newConfig.Dedup.MaxEntries,
                        CleanupInterval: newConfig.Dedup.CleanupInterval,
                }
                mm.deduplicator.UpdateConfig(dedupConfig)
        }</span>

        // 更新生产者配置（需要重启生产者）
        <span class="cov0" title="0">if err := mm.producer.UpdateConfig(newConfig); err != nil </span><span class="cov0" title="0">{
                log.Printf("更新生产者配置失败: %v", err)
                // 不返回错误，因为其他配置已更新
        }</span>

        <span class="cov0" title="0">log.Println("配置热重载完成")
        return nil</span>
}

// printStats 定期打印统计信息
func (mm *MirrorMaker) printStats() <span class="cov0" title="0">{
        defer mm.wg.Done()

        interval := mm.config.Log.StatsInterval
        if interval &lt;= 0 </span><span class="cov0" title="0">{
                interval = 10 * time.Second
        }</span>

        <span class="cov0" title="0">ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-mm.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        mm.stats.mu.RLock()
                        stats := *mm.stats
                        mm.stats.mu.RUnlock()

                        uptime := time.Since(stats.StartTime)
                        var msgRate, bytesRate float64
                        if uptime.Seconds() &gt; 0 </span><span class="cov0" title="0">{
                                msgRate = float64(stats.MessagesConsumed) / uptime.Seconds()
                                bytesRate = float64(stats.BytesConsumed) / uptime.Seconds()
                        }</span>

                        <span class="cov0" title="0">statsMsg := fmt.Sprintf("统计信息 - 运行时间: %v, 消费消息: %d (%.2f msg/s), "+
                                "生产消息: %d, 错误: %d, 消费速率: %.2f KB/s",
                                uptime.Round(time.Second),
                                stats.MessagesConsumed, msgRate,
                                stats.MessagesProduced,
                                stats.Errors,
                                bytesRate/1024)

                        // 同时输出到标准输出和日志文件
                        log.Println(statsMsg)
                        if mm.logger != nil </span><span class="cov0" title="0">{
                                mm.logger.Println(statsMsg)
                        }</span>
                }
        }
}

// handleErrors 处理错误
func (mm *MirrorMaker) handleErrors() <span class="cov0" title="0">{
        defer mm.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-mm.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case err := &lt;-mm.errorChan:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                errMsg := fmt.Sprintf("错误: %v", err)
                                log.Println(errMsg)
                                if mm.logger != nil </span><span class="cov0" title="0">{
                                        mm.logger.Println(errMsg)
                                }</span>
                        }
                }
        }
}

// GetStats 获取统计信息
func (mm *MirrorMaker) GetStats() Stats <span class="cov0" title="0">{
        mm.stats.mu.RLock()
        defer mm.stats.mu.RUnlock()
        return *mm.stats
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package core

import (
        "context"
        "fmt"
        "log"
        "sync"

        "github.com/IBM/sarama"
        
        "message-mirror/internal/pkg/security"
)

// MirrorProducer 镜像生产者
type MirrorProducer struct {
        config   *Config
        producer sarama.AsyncProducer
        ctx      context.Context
        wg       sync.WaitGroup
}

// NewMirrorProducer 创建新的镜像生产者
func NewMirrorProducer(config *Config) (*MirrorProducer, error) <span class="cov0" title="0">{
        // 创建Sarama配置
        saramaConfig := sarama.NewConfig()
        saramaConfig.Version = sarama.V2_8_0_0

        // 生产者配置
        saramaConfig.Producer.Return.Successes = true
        saramaConfig.Producer.Return.Errors = true
        saramaConfig.Producer.RequiredAcks = sarama.RequiredAcks(config.Producer.RequiredAcks)
        saramaConfig.Producer.Retry.Max = config.Producer.RetryMax
        saramaConfig.Producer.Idempotent = config.Producer.Idempotent
        saramaConfig.Producer.MaxMessageBytes = config.Producer.MaxMessageBytes
        saramaConfig.Producer.Flush.Frequency = config.Producer.FlushFrequency

        // 压缩类型
        switch config.Producer.CompressionType </span>{
        case "gzip":<span class="cov0" title="0">
                saramaConfig.Producer.Compression = sarama.CompressionGZIP</span>
        case "snappy":<span class="cov0" title="0">
                saramaConfig.Producer.Compression = sarama.CompressionSnappy</span>
        case "lz4":<span class="cov0" title="0">
                saramaConfig.Producer.Compression = sarama.CompressionLZ4</span>
        case "zstd":<span class="cov0" title="0">
                saramaConfig.Producer.Compression = sarama.CompressionZSTD</span>
        default:<span class="cov0" title="0">
                saramaConfig.Producer.Compression = sarama.CompressionNone</span>
        }

        // TLS配置
        <span class="cov0" title="0">if config.Security.TLS.Enabled </span><span class="cov0" title="0">{
                tlsConfig, err := security.NewTLSConfig(&amp;config.Security.TLS)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("创建TLS配置失败: %w", err)
                }</span>
                <span class="cov0" title="0">if tlsConfig != nil </span><span class="cov0" title="0">{
                        saramaConfig.Net.TLS.Enable = true
                        saramaConfig.Net.TLS.Config = tlsConfig
                }</span>
        }

        // SASL配置
        <span class="cov0" title="0">if config.Target.SecurityProtocol == "SASL_PLAINTEXT" || config.Target.SecurityProtocol == "SASL_SSL" </span><span class="cov0" title="0">{
                saramaConfig.Net.SASL.Enable = true
                saramaConfig.Net.SASL.Mechanism = sarama.SASLTypePlaintext
                saramaConfig.Net.SASL.User = config.Target.SASLUsername
                saramaConfig.Net.SASL.Password = config.Target.SASLPassword
        }</span>

        // 如果启用幂等性，需要设置事务ID
        <span class="cov0" title="0">if config.Producer.Idempotent </span><span class="cov0" title="0">{
                saramaConfig.Producer.Transaction.ID = "mirror-maker-producer"
        }</span>

        // 创建异步生产者
        <span class="cov0" title="0">producer, err := sarama.NewAsyncProducer(config.Target.Brokers, saramaConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("创建生产者失败: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;MirrorProducer{
                config:   config,
                producer: producer,
        }, nil</span>
}

// Start 启动生产者
func (mp *MirrorProducer) Start(ctx context.Context) error <span class="cov0" title="0">{
        mp.ctx = ctx

        // 启动成功消息处理
        mp.wg.Add(1)
        go mp.handleSuccesses()

        // 启动错误消息处理
        mp.wg.Add(1)
        go mp.handleErrors()

        log.Println("生产者已启动")
        return nil
}</span>

// Stop 停止生产者
func (mp *MirrorProducer) Stop() error <span class="cov0" title="0">{
        log.Println("正在停止生产者...")

        // 关闭生产者
        if mp.producer != nil </span><span class="cov0" title="0">{
                if err := mp.producer.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("关闭生产者失败: %w", err)
                }</span>
        }

        // 等待所有goroutine完成
        <span class="cov0" title="0">mp.wg.Wait()

        log.Println("生产者已停止")
        return nil</span>
}

// Send 发送消息
func (mp *MirrorProducer) Send(message *sarama.ProducerMessage) error <span class="cov0" title="0">{
        select </span>{
        case &lt;-mp.ctx.Done():<span class="cov0" title="0">
                return mp.ctx.Err()</span>
        case mp.producer.Input() &lt;- message:<span class="cov0" title="0">
                return nil</span>
        }
}

// handleSuccesses 处理成功发送的消息
func (mp *MirrorProducer) handleSuccesses() <span class="cov0" title="0">{
        defer mp.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-mp.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case msg := &lt;-mp.producer.Successes():<span class="cov0" title="0">
                        if msg != nil </span>{<span class="cov0" title="0">
                                // 可以在这里记录成功的消息
                                // log.Printf("消息发送成功: topic=%s, partition=%d, offset=%d",
                                //     msg.Topic, msg.Partition, msg.Offset)
                        }</span>
                }
        }
}

// handleErrors 处理发送失败的消息
func (mp *MirrorProducer) handleErrors() <span class="cov0" title="0">{
        defer mp.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-mp.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case err := &lt;-mp.producer.Errors():<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("消息发送失败: topic=%s, partition=%d, error=%v",
                                        err.Msg.Topic, err.Msg.Partition, err.Err)
                        }</span>
                }
        }
}

// UpdateConfig 更新配置（注意：生产者配置更新需要重启，这里只更新配置引用）
func (mp *MirrorProducer) UpdateConfig(newConfig *Config) error <span class="cov0" title="0">{
        mp.config = newConfig
        // 注意：Sarama生产者不支持运行时配置更新，需要重启才能生效
        // 这里只更新配置引用，实际配置更新需要在重启时生效
        log.Println("生产者配置已更新（需要重启才能完全生效）")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package deduplicator

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "log"
        "sync"
        "time"
)

// DedupConfig 去重配置（临时定义，后续会从core包导入）
type DedupConfig struct {
        Enabled        bool
        Strategy       string
        TTL            time.Duration
        MaxEntries     int64
        CleanupInterval time.Duration
}

// Message 统一的消息格式（临时定义，后续会从core包导入）
// 注意：这个类型需要与plugin.go中的Message类型兼容
type Message struct {
        Key       []byte
        Value     []byte
        Headers   map[string][]byte
        Timestamp time.Time
        Source    string
        Metadata  map[string]interface{}
}

// DefaultDedupConfig 默认去重配置
func DefaultDedupConfig() *DedupConfig <span class="cov8" title="1">{
        return &amp;DedupConfig{
                Enabled:        false,
                Strategy:       "key_value",
                TTL:            24 * time.Hour,
                MaxEntries:     1000000, // 100万条记录
                CleanupInterval: 1 * time.Hour,
        }
}</span>

// DedupEntry 去重记录
type DedupEntry struct {
        Hash      string
        Timestamp time.Time
}

// Deduplicator 消息去重器
type Deduplicator struct {
        config     *DedupConfig
        entries    map[string]*DedupEntry
        mu         sync.RWMutex
        ctx        context.Context
        cancel     context.CancelFunc
        wg         sync.WaitGroup
        totalDedup int64 // 去重的消息总数
}

// NewDeduplicator 创建新的去重器
func NewDeduplicator(config *DedupConfig, ctx context.Context) *Deduplicator <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = DefaultDedupConfig()
        }</span>

        <span class="cov8" title="1">dedupCtx, cancel := context.WithCancel(ctx)

        deduplicator := &amp;Deduplicator{
                config:  config,
                entries: make(map[string]*DedupEntry),
                ctx:     dedupCtx,
                cancel:  cancel,
        }

        // 如果启用去重，启动清理goroutine
        if config.Enabled </span><span class="cov8" title="1">{
                deduplicator.wg.Add(1)
                go deduplicator.cleanupWorker()
        }</span>

        <span class="cov8" title="1">return deduplicator</span>
}

// IsDuplicate 检查消息是否重复
// 注意：这里接受interface{}，然后转换为内部Message类型
// 后续会统一Message类型定义
func (d *Deduplicator) IsDuplicate(msg interface{}) (bool, error) <span class="cov8" title="1">{
        if !d.config.Enabled </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        // 类型断言转换为内部Message类型
        <span class="cov8" title="1">m, ok := msg.(*Message)
        if !ok </span><span class="cov0" title="0">{
                // 如果不是内部Message类型，尝试从外部Message转换
                // 这里需要根据实际Message结构进行转换
                // 暂时返回错误，后续会统一Message类型
                return false, fmt.Errorf("不支持的消息类型: %T，期望 *deduplicator.Message", msg)
        }</span>

        // 生成去重标识
        <span class="cov8" title="1">hash, err := d.generateHash(m)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("生成去重hash失败: %w", err)
        }</span>

        <span class="cov8" title="1">d.mu.Lock()
        defer d.mu.Unlock()

        // 检查是否已存在
        if entry, exists := d.entries[hash]; exists </span><span class="cov8" title="1">{
                // 检查是否过期
                if time.Since(entry.Timestamp) &lt; d.config.TTL </span><span class="cov8" title="1">{
                        d.totalDedup++
                        return true, nil
                }</span>
                // 已过期，删除旧记录
                <span class="cov0" title="0">delete(d.entries, hash)</span>
        }

        // 检查是否超过最大记录数
        <span class="cov8" title="1">if int64(len(d.entries)) &gt;= d.config.MaxEntries </span><span class="cov0" title="0">{
                // 清理最旧的记录
                d.cleanupOldest()
        }</span>

        // 添加新记录
        <span class="cov8" title="1">d.entries[hash] = &amp;DedupEntry{
                Hash:      hash,
                Timestamp: time.Now(),
        }

        return false, nil</span>
}

// generateHash 生成消息的去重hash
func (d *Deduplicator) generateHash(msg *Message) (string, error) <span class="cov8" title="1">{
        var data []byte

        switch d.config.Strategy </span>{
        case "key":<span class="cov8" title="1">
                // 仅使用Key
                data = msg.Key</span>
        case "value":<span class="cov8" title="1">
                // 仅使用Value
                data = msg.Value</span>
        case "key_value":<span class="cov8" title="1">
                // 使用Key和Value的组合
                data = append(msg.Key, msg.Value...)</span>
        case "hash":<span class="cov0" title="0">
                // 使用消息的完整内容（包括headers）
                data = append(msg.Key, msg.Value...)
                for k, v := range msg.Headers </span><span class="cov0" title="0">{
                        data = append(data, []byte(k)...)
                        data = append(data, v...)
                }</span>
        default:<span class="cov0" title="0">
                // 默认使用key_value策略
                data = append(msg.Key, msg.Value...)</span>
        }

        // 生成SHA256 hash
        <span class="cov8" title="1">hash := sha256.Sum256(data)
        return hex.EncodeToString(hash[:]), nil</span>
}

// cleanupOldest 清理最旧的记录（保留一半）
func (d *Deduplicator) cleanupOldest() <span class="cov0" title="0">{
        // 按时间戳排序
        type entryTime struct {
                hash string
                time time.Time
        }

        entries := make([]entryTime, 0, len(d.entries))
        for hash, entry := range d.entries </span><span class="cov0" title="0">{
                entries = append(entries, entryTime{hash: hash, time: entry.Timestamp})
        }</span>

        // 简单清理：删除一半最旧的记录
        <span class="cov0" title="0">toDelete := len(d.entries) / 2
        for i := 0; i &lt; toDelete &amp;&amp; i &lt; len(entries); i++ </span><span class="cov0" title="0">{
                delete(d.entries, entries[i].hash)
        }</span>
}

// cleanupWorker 定期清理过期记录的goroutine
func (d *Deduplicator) cleanupWorker() <span class="cov8" title="1">{
        defer d.wg.Done()

        ticker := time.NewTicker(d.config.CleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-d.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        d.cleanupExpired()</span>
                }
        }
}

// cleanupExpired 清理过期的记录
func (d *Deduplicator) cleanupExpired() <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()

        now := time.Now()
        expiredCount := 0

        for hash, entry := range d.entries </span><span class="cov0" title="0">{
                if now.Sub(entry.Timestamp) &gt;= d.config.TTL </span><span class="cov0" title="0">{
                        delete(d.entries, hash)
                        expiredCount++
                }</span>
        }

        <span class="cov0" title="0">if expiredCount &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("[去重器] 清理了 %d 条过期记录，当前记录数: %d", expiredCount, len(d.entries))
        }</span>
}

// GetStats 获取去重统计信息
func (d *Deduplicator) GetStats() (int64, int) <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        return d.totalDedup, len(d.entries)
}</span>

// Stop 停止去重器
func (d *Deduplicator) Stop() <span class="cov8" title="1">{
        d.cancel()
        d.wg.Wait()

        d.mu.Lock()
        defer d.mu.Unlock()

        log.Printf("[去重器] 已停止，总共去重 %d 条消息，当前记录数: %d", d.totalDedup, len(d.entries))
}</span>

// UpdateConfig 更新去重器配置
func (d *Deduplicator) UpdateConfig(newConfig *DedupConfig) <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()

        oldEnabled := d.config.Enabled
        d.config = newConfig

        // 如果从禁用变为启用，启动清理goroutine
        if !oldEnabled &amp;&amp; newConfig.Enabled </span><span class="cov0" title="0">{
                d.wg.Add(1)
                go d.cleanupWorker()
        }</span>

        // 如果从启用变为禁用，停止清理goroutine
        <span class="cov0" title="0">if oldEnabled &amp;&amp; !newConfig.Enabled </span><span class="cov0" title="0">{
                d.cancel()
                d.wg.Wait()
                // 重新创建context
                d.ctx, d.cancel = context.WithCancel(context.Background())
        }</span>
}

</pre>
		
		<pre class="file" id="file8" style="display: none">package deduplicator

import (
        "context"
        "testing"
        "time"
)

func TestDeduplicator_CleanupExpired(t *testing.T) <span class="cov0" title="0">{
        config := &amp;DedupConfig{
                Enabled:        true,
                Strategy:       "key_value",
                TTL:            100 * time.Millisecond, // 短TTL用于测试
                MaxEntries:     1000,
                CleanupInterval: 50 * time.Millisecond, // 短清理间隔
        }
        
        ctx := context.Background()
        deduplicator := NewDeduplicator(config, ctx)
        defer deduplicator.Stop()
        
        msg1 := &amp;Message{
                Key:   []byte("test-key-1"),
                Value: []byte("test-value-1"),
        }
        
        msg2 := &amp;Message{
                Key:   []byte("test-key-2"),
                Value: []byte("test-value-2"),
        }
        
        // 添加消息
        deduplicator.IsDuplicate(msg1)
        deduplicator.IsDuplicate(msg2)
        
        // 等待TTL过期
        time.Sleep(150 * time.Millisecond)
        
        // 等待清理
        time.Sleep(100 * time.Millisecond)
        
        // 检查统计信息
        totalDedup, entries := deduplicator.GetStats()
        t.Logf("去重统计: 总数=%d, 当前记录数=%d", totalDedup, entries)
}</span>

func TestDeduplicator_CleanupOldest(t *testing.T) <span class="cov0" title="0">{
        config := &amp;DedupConfig{
                Enabled:        true,
                Strategy:       "key_value",
                TTL:            1 * time.Hour,
                MaxEntries:     3, // 小数量用于测试清理
                CleanupInterval: 1 * time.Hour,
        }
        
        ctx := context.Background()
        deduplicator := NewDeduplicator(config, ctx)
        defer deduplicator.Stop()
        
        // 添加超过最大记录数的消息
        for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                msg := &amp;Message{
                        Key:   []byte("test-key"),
                        Value: []byte{byte(i)},
                }
                deduplicator.IsDuplicate(msg)
        }</span>
        
        // 检查统计信息
        <span class="cov0" title="0">totalDedup, entries := deduplicator.GetStats()
        t.Logf("去重统计: 总数=%d, 当前记录数=%d", totalDedup, entries)
        
        // 记录数应该不超过MaxEntries
        if entries &gt; int(config.MaxEntries) </span><span class="cov0" title="0">{
                t.Errorf("记录数不应该超过MaxEntries，实际%d，最大%d", entries, config.MaxEntries)
        }</span>
}

func TestDeduplicator_GenerateHash_AllStrategies(t *testing.T) <span class="cov0" title="0">{
        configs := []struct {
                name    string
                config  *DedupConfig
        }{
                {"key", &amp;DedupConfig{Enabled: true, Strategy: "key", TTL: 1 * time.Hour, MaxEntries: 1000, CleanupInterval: 1 * time.Hour}},
                {"value", &amp;DedupConfig{Enabled: true, Strategy: "value", TTL: 1 * time.Hour, MaxEntries: 1000, CleanupInterval: 1 * time.Hour}},
                {"key_value", &amp;DedupConfig{Enabled: true, Strategy: "key_value", TTL: 1 * time.Hour, MaxEntries: 1000, CleanupInterval: 1 * time.Hour}},
                {"hash", &amp;DedupConfig{Enabled: true, Strategy: "hash", TTL: 1 * time.Hour, MaxEntries: 1000, CleanupInterval: 1 * time.Hour}},
                {"invalid", &amp;DedupConfig{Enabled: true, Strategy: "invalid", TTL: 1 * time.Hour, MaxEntries: 1000, CleanupInterval: 1 * time.Hour}},
        }
        
        msg := &amp;Message{
                Key:   []byte("test-key"),
                Value: []byte("test-value"),
                Headers: map[string][]byte{
                        "header1": []byte("value1"),
                },
        }
        
        for _, tc := range configs </span><span class="cov0" title="0">{
                t.Run(tc.name, func(t *testing.T) </span><span class="cov0" title="0">{
                        ctx := context.Background()
                        deduplicator := NewDeduplicator(tc.config, ctx)
                        defer deduplicator.Stop()
                        
                        // 测试hash生成（通过IsDuplicate间接测试）
                        isDup, err := deduplicator.IsDuplicate(msg)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Errorf("生成hash失败: %v", err)
                        }</span>
                        
                        <span class="cov0" title="0">if isDup </span><span class="cov0" title="0">{
                                t.Error("第一条消息不应该是重复的")
                        }</span>
                        
                        // 再次检查应该是重复的
                        <span class="cov0" title="0">isDup, err = deduplicator.IsDuplicate(msg)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Errorf("生成hash失败: %v", err)
                        }</span>
                        
                        <span class="cov0" title="0">if !isDup </span><span class="cov0" title="0">{
                                t.Error("相同消息应该是重复的")
                        }</span>
                })
        }
}

</pre>
		
		<pre class="file" id="file9" style="display: none">package logger

import (
        "archive/tar"
        "compress/gzip"
        "context"
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"
        "sort"
        "sync"
        "time"
)

// LogConfig 日志配置（临时定义，后续会从core包导入）
type LogConfig struct {
        FilePath         string
        StatsInterval    time.Duration
        RotateInterval   time.Duration
        MaxArchiveFiles  int
        AsyncBufferSize  int
}

// Logger 异步日志管理器
type Logger struct {
        config      *LogConfig
        file        *os.File
        filePath    string
        writeChan   chan string
        ctx         context.Context
        cancel      context.CancelFunc
        wg          sync.WaitGroup
        mu          sync.RWMutex
        lastRotate  time.Time
}

// NewLogger 创建新的日志管理器
func NewLogger(config *LogConfig, ctx context.Context) (*Logger, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = &amp;LogConfig{
                        FilePath:         "message-mirror.log",
                        StatsInterval:    10 * time.Second,
                        RotateInterval:   24 * time.Hour,
                        MaxArchiveFiles:  7,
                        AsyncBufferSize: 1000,
                }
        }</span>

        <span class="cov8" title="1">loggerCtx, cancel := context.WithCancel(ctx)

        logger := &amp;Logger{
                config:     config,
                filePath:   config.FilePath,
                writeChan:  make(chan string, config.AsyncBufferSize),
                ctx:        loggerCtx,
                cancel:     cancel,
                lastRotate: time.Now(),
        }

        // 打开日志文件
        if err := logger.openFile(); err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("打开日志文件失败: %w", err)
        }</span>

        // 启动异步写入goroutine
        <span class="cov8" title="1">logger.wg.Add(1)
        go logger.asyncWriter()

        // 启动日志轮转goroutine
        logger.wg.Add(1)
        go logger.rotateWorker()

        return logger, nil</span>
}

// openFile 打开日志文件
func (l *Logger) openFile() error <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()

        // 确保目录存在
        dir := filepath.Dir(l.filePath)
        if dir != "." &amp;&amp; dir != "" </span><span class="cov0" title="0">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("创建日志目录失败: %w", err)
                }</span>
        }

        <span class="cov8" title="1">file, err := os.OpenFile(l.filePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 关闭旧文件
        <span class="cov8" title="1">if l.file != nil </span><span class="cov0" title="0">{
                l.file.Close()
        }</span>

        <span class="cov8" title="1">l.file = file
        return nil</span>
}

// asyncWriter 异步写入goroutine
func (l *Logger) asyncWriter() <span class="cov8" title="1">{
        defer l.wg.Done()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-l.ctx.Done():<span class="cov8" title="1">
                        // 关闭前写入所有待写入的消息
                        l.flush()
                        return</span>

                case msg := &lt;-l.writeChan:<span class="cov8" title="1">
                        l.mu.RLock()
                        file := l.file
                        l.mu.RUnlock()

                        if file != nil </span><span class="cov8" title="1">{
                                timestamp := time.Now().Format("2006-01-02 15:04:05")
                                logLine := fmt.Sprintf("[%s] %s\n", timestamp, msg)
                                
                                if _, err := file.WriteString(logLine); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("写入日志失败: %v", err)
                                }</span>
                        }
                }
        }
}

// flush 刷新所有待写入的消息
func (l *Logger) flush() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case msg := &lt;-l.writeChan:<span class="cov8" title="1">
                        l.mu.RLock()
                        file := l.file
                        l.mu.RUnlock()

                        if file != nil </span><span class="cov8" title="1">{
                                timestamp := time.Now().Format("2006-01-02 15:04:05")
                                logLine := fmt.Sprintf("[%s] %s\n", timestamp, msg)
                                file.WriteString(logLine)
                        }</span>
                default:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// rotateWorker 日志轮转工作goroutine
func (l *Logger) rotateWorker() <span class="cov8" title="1">{
        defer l.wg.Done()

        ticker := time.NewTicker(1 * time.Hour) // 每小时检查一次
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-l.ctx.Done():<span class="cov8" title="1">
                        return</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        if time.Since(l.lastRotate) &gt;= l.config.RotateInterval </span><span class="cov0" title="0">{
                                if err := l.rotate(); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("日志轮转失败: %v", err)
                                }</span>
                        }
                }
        }
}

// rotate 执行日志轮转
func (l *Logger) rotate() error <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()

        // 关闭当前文件
        if l.file != nil </span><span class="cov0" title="0">{
                l.file.Close()
                l.file = nil
        }</span>

        // 如果日志文件不存在或为空，直接打开新文件
        <span class="cov0" title="0">info, err := os.Stat(l.filePath)
        if err != nil || info.Size() == 0 </span><span class="cov0" title="0">{
                l.lastRotate = time.Now()
                return l.openFile()
        }</span>

        // 生成归档文件名（带时间戳）
        <span class="cov0" title="0">timestamp := time.Now().Format("20060102-150405")
        archivePath := fmt.Sprintf("%s.%s.tar.gz", l.filePath, timestamp)

        // 压缩当前日志文件
        if err := l.compressLogFile(l.filePath, archivePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("压缩日志文件失败: %w", err)
        }</span>

        // 删除原始日志文件
        <span class="cov0" title="0">if err := os.Remove(l.filePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("删除原始日志文件失败: %w", err)
        }</span>

        // 清理旧的归档文件
        <span class="cov0" title="0">if err := l.cleanupOldArchives(); err != nil </span><span class="cov0" title="0">{
                log.Printf("清理旧归档文件失败: %v", err)
        }</span>

        // 打开新的日志文件
        <span class="cov0" title="0">l.lastRotate = time.Now()
        return l.openFile()</span>
}

// compressLogFile 压缩日志文件为tar.gz
func (l *Logger) compressLogFile(srcPath, destPath string) error <span class="cov0" title="0">{
        // 打开源文件
        srcFile, err := os.Open(srcPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer srcFile.Close()

        // 创建目标文件
        destFile, err := os.Create(destPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer destFile.Close()

        // 创建gzip writer
        gzWriter := gzip.NewWriter(destFile)
        defer gzWriter.Close()

        // 创建tar writer
        tarWriter := tar.NewWriter(gzWriter)
        defer tarWriter.Close()

        // 获取文件信息
        info, err := srcFile.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 创建tar header
        <span class="cov0" title="0">header, err := tar.FileInfoHeader(info, "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">header.Name = filepath.Base(srcPath)

        // 写入header
        if err := tarWriter.WriteHeader(header); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 复制文件内容
        <span class="cov0" title="0">if _, err := io.Copy(tarWriter, srcFile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// cleanupOldArchives 清理旧的归档文件
func (l *Logger) cleanupOldArchives() error <span class="cov0" title="0">{
        logDir := filepath.Dir(l.filePath)
        if logDir == "." || logDir == "" </span><span class="cov0" title="0">{
                logDir = "."
        }</span>

        <span class="cov0" title="0">baseName := filepath.Base(l.filePath)
        pattern := fmt.Sprintf("%s.*.tar.gz", baseName)

        // 查找所有匹配的归档文件
        matches, err := filepath.Glob(filepath.Join(logDir, pattern))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 如果归档文件数量超过限制，删除最旧的
        <span class="cov0" title="0">if len(matches) &gt; l.config.MaxArchiveFiles </span><span class="cov0" title="0">{
                // 按文件名排序（文件名包含时间戳，所以可以按文件名排序）
                sort.Strings(matches)

                // 删除最旧的文件
                toDelete := len(matches) - l.config.MaxArchiveFiles
                for i := 0; i &lt; toDelete; i++ </span><span class="cov0" title="0">{
                        if err := os.Remove(matches[i]); err != nil </span><span class="cov0" title="0">{
                                log.Printf("删除归档文件失败 %s: %v", matches[i], err)
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("删除旧归档文件: %s", matches[i])
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// Write 写入日志（异步）
func (l *Logger) Write(msg string) <span class="cov8" title="1">{
        select </span>{
        case l.writeChan &lt;- msg:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0">
                // 如果缓冲区满了，直接输出到标准错误（避免阻塞）
                log.Printf("日志缓冲区已满，直接输出: %s", msg)</span>
        }
}

// Printf 格式化写入日志（异步）
func (l *Logger) Printf(format string, args ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, args...)
        l.Write(msg)
}</span>

// Println 写入日志行（异步）
func (l *Logger) Println(args ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintln(args...)
        // 移除末尾的换行符（Write会添加）
        msg = msg[:len(msg)-1]
        l.Write(msg)
}</span>

// Stop 停止日志管理器
func (l *Logger) Stop() error <span class="cov8" title="1">{
        l.cancel()
        l.wg.Wait()

        l.mu.Lock()
        defer l.mu.Unlock()

        if l.file != nil </span><span class="cov8" title="1">{
                return l.file.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package logger

import (
        "context"
        "os"
        "testing"
        "time"
)

func TestLogger_Rotate(t *testing.T) <span class="cov0" title="0">{
        config := &amp;LogConfig{
                FilePath:         "test-rotate.log",
                StatsInterval:    10 * time.Second,
                RotateInterval:   100 * time.Millisecond, // 短间隔用于测试
                MaxArchiveFiles:  3,
                AsyncBufferSize:  100,
        }
        
        ctx := context.Background()
        logger, err := NewLogger(config, ctx)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("创建日志管理器失败: %v", err)
        }</span>
        
        // 写入一些日志
        <span class="cov0" title="0">for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                logger.Write("测试日志消息")
        }</span>
        
        // 等待轮转
        <span class="cov0" title="0">time.Sleep(200 * time.Millisecond)
        
        // 停止日志管理器
        if err := logger.Stop(); err != nil </span><span class="cov0" title="0">{
                t.Errorf("停止日志管理器失败: %v", err)
        }</span>
        
        // 清理
        <span class="cov0" title="0">os.Remove("test-rotate.log")
        os.Remove("test-rotate.log.tar.gz")</span>
}

func TestLogger_Printf(t *testing.T) <span class="cov0" title="0">{
        config := &amp;LogConfig{
                FilePath:         "test-printf.log",
                StatsInterval:    10 * time.Second,
                RotateInterval:   24 * time.Hour,
                MaxArchiveFiles:  7,
                AsyncBufferSize:  100,
        }
        
        ctx := context.Background()
        logger, err := NewLogger(config, ctx)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("创建日志管理器失败: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                logger.Stop()
                os.Remove("test-printf.log")
        }</span>()
        
        <span class="cov0" title="0">logger.Printf("格式化日志: %s, %d", "测试", 123)
        
        // 等待异步写入
        time.Sleep(100 * time.Millisecond)
        
        if _, err := os.Stat("test-printf.log"); os.IsNotExist(err) </span><span class="cov0" title="0">{
                t.Error("日志文件应该被创建")
        }</span>
}

func TestLogger_Println(t *testing.T) <span class="cov0" title="0">{
        config := &amp;LogConfig{
                FilePath:         "test-println.log",
                StatsInterval:    10 * time.Second,
                RotateInterval:   24 * time.Hour,
                MaxArchiveFiles:  7,
                AsyncBufferSize:  100,
        }
        
        ctx := context.Background()
        logger, err := NewLogger(config, ctx)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("创建日志管理器失败: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                logger.Stop()
                os.Remove("test-println.log")
        }</span>()
        
        <span class="cov0" title="0">logger.Println("日志行测试")
        
        // 等待异步写入
        time.Sleep(100 * time.Millisecond)
        
        if _, err := os.Stat("test-println.log"); os.IsNotExist(err) </span><span class="cov0" title="0">{
                t.Error("日志文件应该被创建")
        }</span>
}

</pre>
		
		<pre class="file" id="file11" style="display: none">package metrics

import (
        "sync"
        "time"

        "github.com/prometheus/client_golang/prometheus"
)

// Metrics 指标管理器
type Metrics struct {
        // 消息计数器
        MessagesConsumedTotal prometheus.Counter
        MessagesProducedTotal prometheus.Counter
        MessagesFailedTotal  prometheus.Counter

        // 字节计数器
        BytesConsumedTotal prometheus.Counter
        BytesProducedTotal prometheus.Counter

        // 延迟直方图
        MessageLatency prometheus.Histogram

        // 速率仪表盘
        MessageRate prometheus.Gauge
        ByteRate    prometheus.Gauge

        // 错误率
        ErrorRate prometheus.Gauge

        // 健康状态
        HealthStatus prometheus.Gauge

        // 内部状态
        mu            sync.RWMutex
        lastUpdate    time.Time
        messageCount  int64
        byteCount     int64
        errorCount    int64
}

// NewMetrics 创建新的指标管理器
func NewMetrics() *Metrics <span class="cov8" title="1">{
        return &amp;Metrics{
                MessagesConsumedTotal: prometheus.NewCounter(prometheus.CounterOpts{
                        Name: "message_mirror_messages_consumed_total",
                        Help: "Total number of messages consumed",
                }),
                MessagesProducedTotal: prometheus.NewCounter(prometheus.CounterOpts{
                        Name: "message_mirror_messages_produced_total",
                        Help: "Total number of messages produced",
                }),
                MessagesFailedTotal: prometheus.NewCounter(prometheus.CounterOpts{
                        Name: "message_mirror_messages_failed_total",
                        Help: "Total number of messages failed",
                }),
                BytesConsumedTotal: prometheus.NewCounter(prometheus.CounterOpts{
                        Name: "message_mirror_bytes_consumed_total",
                        Help: "Total number of bytes consumed",
                }),
                BytesProducedTotal: prometheus.NewCounter(prometheus.CounterOpts{
                        Name: "message_mirror_bytes_produced_total",
                        Help: "Total number of bytes produced",
                }),
                MessageLatency: prometheus.NewHistogram(prometheus.HistogramOpts{
                        Name:    "message_mirror_message_latency_seconds",
                        Help:    "Message processing latency in seconds",
                        Buckets: prometheus.ExponentialBuckets(0.001, 2, 15), // 1ms to ~32s
                }),
                MessageRate: prometheus.NewGauge(prometheus.GaugeOpts{
                        Name: "message_mirror_message_rate_per_second",
                        Help: "Current message processing rate per second",
                }),
                ByteRate: prometheus.NewGauge(prometheus.GaugeOpts{
                        Name: "message_mirror_byte_rate_per_second",
                        Help: "Current byte processing rate per second",
                }),
                ErrorRate: prometheus.NewGauge(prometheus.GaugeOpts{
                        Name: "message_mirror_error_rate",
                        Help: "Current error rate",
                }),
                HealthStatus: prometheus.NewGauge(prometheus.GaugeOpts{
                        Name: "message_mirror_health_status",
                        Help: "Health status (1 = healthy, 0 = unhealthy)",
                }),
                lastUpdate: time.Now(),
        }
}</span>

// Register 注册所有指标
func (m *Metrics) Register() <span class="cov0" title="0">{
        prometheus.MustRegister(
                m.MessagesConsumedTotal,
                m.MessagesProducedTotal,
                m.MessagesFailedTotal,
                m.BytesConsumedTotal,
                m.BytesProducedTotal,
                m.MessageLatency,
                m.MessageRate,
                m.ByteRate,
                m.ErrorRate,
                m.HealthStatus,
        )
}</span>

// RecordMessageConsumed 记录消息消费
func (m *Metrics) RecordMessageConsumed(bytes int) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.MessagesConsumedTotal.Inc()
        m.BytesConsumedTotal.Add(float64(bytes))
        m.messageCount++
        m.byteCount += int64(bytes)
}</span>

// RecordMessageProduced 记录消息生产
func (m *Metrics) RecordMessageProduced(bytes int) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.MessagesProducedTotal.Inc()
        m.BytesProducedTotal.Add(float64(bytes))
}</span>

// RecordMessageFailed 记录消息失败
func (m *Metrics) RecordMessageFailed() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.MessagesFailedTotal.Inc()
        m.errorCount++
}</span>

// RecordLatency 记录延迟
func (m *Metrics) RecordLatency(duration time.Duration) <span class="cov8" title="1">{
        m.MessageLatency.Observe(duration.Seconds())
}</span>

// UpdateRates 更新速率指标
func (m *Metrics) UpdateRates() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        now := time.Now()
        elapsed := now.Sub(m.lastUpdate).Seconds()

        if elapsed &gt; 0 </span><span class="cov8" title="1">{
                msgRate := float64(m.messageCount) / elapsed
                byteRate := float64(m.byteCount) / elapsed
                errRate := float64(m.errorCount) / elapsed

                m.MessageRate.Set(msgRate)
                m.ByteRate.Set(byteRate)
                m.ErrorRate.Set(errRate)

                // 重置计数器
                m.messageCount = 0
                m.byteCount = 0
                m.errorCount = 0
                m.lastUpdate = now
        }</span>
}

// SetHealthStatus 设置健康状态
func (m *Metrics) SetHealthStatus(healthy bool) <span class="cov8" title="1">{
        if healthy </span><span class="cov8" title="1">{
                m.HealthStatus.Set(1)
        }</span> else<span class="cov8" title="1"> {
                m.HealthStatus.Set(0)
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package optimization

import (
        "context"
        "log"
        "sync"
        "time"
)

// Message 统一的消息格式（临时定义，后续会从core包导入）
type Message struct {
        Key       []byte
        Value     []byte
        Headers   map[string][]byte
        Timestamp time.Time
        Source    string
        Metadata  map[string]interface{}
}

// BatchProcessor 批处理器，用于优化消息处理性能
type BatchProcessor struct {
        batchSize     int
        batchTimeout  time.Duration
        processor     func([]*Message) error
        messageChan   chan *Message
        batch         []*Message
        mu            sync.Mutex
        wg            sync.WaitGroup
        ctx           context.Context
        cancel        context.CancelFunc
}

// NewBatchProcessor 创建新的批处理器
func NewBatchProcessor(batchSize int, batchTimeout time.Duration, processor func([]*Message) error) *BatchProcessor <span class="cov8" title="1">{
        return &amp;BatchProcessor{
                batchSize:    batchSize,
                batchTimeout: batchTimeout,
                processor:    processor,
                messageChan:  make(chan *Message, batchSize*2),
                batch:        make([]*Message, 0, batchSize),
        }
}</span>

// Start 启动批处理器
func (bp *BatchProcessor) Start(ctx context.Context) <span class="cov8" title="1">{
        bp.ctx, bp.cancel = context.WithCancel(ctx)
        bp.wg.Add(1)
        go bp.processBatch()
}</span>

// Stop 停止批处理器
func (bp *BatchProcessor) Stop() <span class="cov8" title="1">{
        if bp.cancel != nil </span><span class="cov8" title="1">{
                bp.cancel()
        }</span>
        <span class="cov8" title="1">if bp.messageChan != nil </span><span class="cov8" title="1">{
                close(bp.messageChan)
        }</span>
        <span class="cov8" title="1">bp.wg.Wait()</span>
}

// UpdateConfig 更新批处理器配置
func (bp *BatchProcessor) UpdateConfig(batchSize int, batchTimeout time.Duration) <span class="cov0" title="0">{
        bp.mu.Lock()
        defer bp.mu.Unlock()
        bp.batchSize = batchSize
        bp.batchTimeout = batchTimeout
}</span>

// Add 添加消息到批处理队列
func (bp *BatchProcessor) Add(msg *Message) error <span class="cov8" title="1">{
        select </span>{
        case &lt;-bp.ctx.Done():<span class="cov0" title="0">
                return bp.ctx.Err()</span>
        case bp.messageChan &lt;- msg:<span class="cov8" title="1">
                return nil</span>
        }
}

// processBatch 处理批次消息
func (bp *BatchProcessor) processBatch() <span class="cov8" title="1">{
        defer bp.wg.Done()
        
        ticker := time.NewTicker(bp.batchTimeout)
        defer ticker.Stop()
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-bp.ctx.Done():<span class="cov8" title="1">
                        // 处理剩余消息
                        bp.flushBatch()
                        return</span>
                        
                case msg, ok := &lt;-bp.messageChan:<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                bp.flushBatch()
                                return
                        }</span>
                        
                        <span class="cov8" title="1">bp.mu.Lock()
                        bp.batch = append(bp.batch, msg)
                        shouldFlush := len(bp.batch) &gt;= bp.batchSize
                        bp.mu.Unlock()
                        
                        if shouldFlush </span><span class="cov8" title="1">{
                                bp.flushBatch()
                                ticker.Reset(bp.batchTimeout)
                        }</span>
                        
                case &lt;-ticker.C:<span class="cov8" title="1">
                        bp.flushBatch()</span>
                }
        }
}

// flushBatch 刷新批次
func (bp *BatchProcessor) flushBatch() <span class="cov8" title="1">{
        bp.mu.Lock()
        if len(bp.batch) == 0 </span><span class="cov8" title="1">{
                bp.mu.Unlock()
                return
        }</span>
        
        <span class="cov8" title="1">batch := make([]*Message, len(bp.batch))
        copy(batch, bp.batch)
        bp.batch = bp.batch[:0]
        bp.mu.Unlock()
        
        // 处理批次
        if bp.processor != nil </span><span class="cov8" title="1">{
                if err := bp.processor(batch); err != nil </span><span class="cov0" title="0">{
                        log.Printf("批处理失败: %v", err)
                }</span>
        }
}

// ConnectionPool 连接池（用于Kafka生产者优化）
type ConnectionPool struct {
        poolSize int
        mu       sync.RWMutex
        stats    *PoolStats
}

// PoolStats 连接池统计信息
type PoolStats struct {
        ActiveConnections int64
        TotalConnections  int64
        ConnectionErrors  int64
}

// NewConnectionPool 创建新的连接池
func NewConnectionPool(poolSize int) *ConnectionPool <span class="cov8" title="1">{
        return &amp;ConnectionPool{
                poolSize: poolSize,
                stats:    &amp;PoolStats{},
        }
}</span>

// GetStats 获取连接池统计信息
func (cp *ConnectionPool) GetStats() PoolStats <span class="cov8" title="1">{
        cp.mu.RLock()
        defer cp.mu.RUnlock()
        return *cp.stats
}</span>

// MessageCache 消息缓存（用于去重优化）
type MessageCache struct {
        cache     map[string]*CacheEntry
        mu        sync.RWMutex
        maxSize   int
        ttl       time.Duration
        cleanupCh chan struct{}
}

// CacheEntry 缓存条目
type CacheEntry struct {
        Hash      string
        Timestamp time.Time
}

// NewMessageCache 创建新的消息缓存
func NewMessageCache(maxSize int, ttl time.Duration) *MessageCache <span class="cov8" title="1">{
        cache := &amp;MessageCache{
                cache:     make(map[string]*CacheEntry),
                maxSize:   maxSize,
                ttl:       ttl,
                cleanupCh: make(chan struct{}),
        }
        
        // 启动清理goroutine
        go cache.cleanup()
        
        return cache
}</span>

// Get 获取缓存条目
func (mc *MessageCache) Get(key string) (bool, bool) <span class="cov8" title="1">{
        mc.mu.RLock()
        defer mc.mu.RUnlock()
        
        entry, exists := mc.cache[key]
        if !exists </span><span class="cov8" title="1">{
                return false, false
        }</span>
        
        // 检查是否过期
        <span class="cov8" title="1">if time.Since(entry.Timestamp) &gt;= mc.ttl </span><span class="cov0" title="0">{
                return false, true // 存在但已过期
        }</span>
        
        <span class="cov8" title="1">return true, true</span> // 存在且有效
}

// Set 设置缓存条目
func (mc *MessageCache) Set(key string, hash string) <span class="cov8" title="1">{
        mc.mu.Lock()
        defer mc.mu.Unlock()
        
        // 如果超过最大大小，清理最旧的条目
        if len(mc.cache) &gt;= mc.maxSize </span><span class="cov0" title="0">{
                mc.evictOldest()
        }</span>
        
        <span class="cov8" title="1">mc.cache[key] = &amp;CacheEntry{
                Hash:      hash,
                Timestamp: time.Now(),
        }</span>
}

// evictOldest 清理最旧的条目
func (mc *MessageCache) evictOldest() <span class="cov0" title="0">{
        oldestKey := ""
        oldestTime := time.Now()
        
        for k, v := range mc.cache </span><span class="cov0" title="0">{
                if v.Timestamp.Before(oldestTime) </span><span class="cov0" title="0">{
                        oldestTime = v.Timestamp
                        oldestKey = k
                }</span>
        }
        
        <span class="cov0" title="0">if oldestKey != "" </span><span class="cov0" title="0">{
                delete(mc.cache, oldestKey)
        }</span>
}

// cleanup 定期清理过期条目
func (mc *MessageCache) cleanup() <span class="cov8" title="1">{
        ticker := time.NewTicker(mc.ttl / 2)
        defer ticker.Stop()
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        mc.cleanupExpired()</span>
                case &lt;-mc.cleanupCh:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// cleanupExpired 清理过期条目
func (mc *MessageCache) cleanupExpired() <span class="cov0" title="0">{
        mc.mu.Lock()
        defer mc.mu.Unlock()
        
        now := time.Now()
        for k, v := range mc.cache </span><span class="cov0" title="0">{
                if now.Sub(v.Timestamp) &gt;= mc.ttl </span><span class="cov0" title="0">{
                        delete(mc.cache, k)
                }</span>
        }
}

// Stop 停止缓存
func (mc *MessageCache) Stop() <span class="cov8" title="1">{
        close(mc.cleanupCh)
}</span>

</pre>
		
		<pre class="file" id="file13" style="display: none">package optimization

import (
        "context"
        "testing"
        "time"
)

func TestBatchProcessor_FlushOnTimeout(t *testing.T) <span class="cov0" title="0">{
        processedBatches := 0
        
        processor := func(batch []*Message) error </span><span class="cov0" title="0">{
                processedBatches++
                return nil
        }</span>
        
        <span class="cov0" title="0">ctx := context.Background()
        batchProcessor := NewBatchProcessor(100, 100*time.Millisecond, processor)
        batchProcessor.Start(ctx)
        defer batchProcessor.Stop()
        
        // 添加少量消息
        msg := &amp;Message{
                Key:   []byte("key"),
                Value: []byte("value"),
        }
        batchProcessor.Add(msg)
        
        // 等待超时刷新
        time.Sleep(200 * time.Millisecond)
        
        if processedBatches == 0 </span><span class="cov0" title="0">{
                t.Error("应该至少处理一个批次（超时刷新）")
        }</span>
}

func TestBatchProcessor_ContextCancellation(t *testing.T) <span class="cov0" title="0">{
        processor := func(batch []*Message) error </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        batchProcessor := NewBatchProcessor(10, 100*time.Millisecond, processor)
        batchProcessor.Start(ctx)
        
        // 添加一些消息
        for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                msg := &amp;Message{
                        Key:   []byte("key"),
                        Value: []byte("value"),
                }
                batchProcessor.Add(msg)
        }</span>
        
        // 取消上下文
        <span class="cov0" title="0">cancel()
        
        // 等待停止
        time.Sleep(100 * time.Millisecond)
        
        // Stop应该正常完成
        batchProcessor.Stop()</span>
}

func TestMessageCache_EvictOldest(t *testing.T) <span class="cov0" title="0">{
        cache := NewMessageCache(3, 1*time.Hour)
        defer cache.Stop()
        
        // 添加超过最大大小的条目
        cache.Set("key1", "hash1")
        cache.Set("key2", "hash2")
        cache.Set("key3", "hash3")
        cache.Set("key4", "hash4") // 应该触发清理
        
        // 检查条目数
        exists, _ := cache.Get("key1")
        if exists </span><span class="cov0" title="0">{
                // key1可能被清理，也可能还在（取决于清理策略）
                t.Log("key1可能已被清理")
        }</span>
}

func TestMessageCache_Expired(t *testing.T) <span class="cov0" title="0">{
        cache := NewMessageCache(100, 100*time.Millisecond) // 短TTL
        defer cache.Stop()
        
        cache.Set("key1", "hash1")
        
        // 等待过期
        time.Sleep(150 * time.Millisecond)
        
        // 检查是否过期
        exists, valid := cache.Get("key1")
        if exists &amp;&amp; valid </span><span class="cov0" title="0">{
                t.Error("过期的条目应该被标记为无效")
        }</span>
        
        // 等待清理
        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)
        
        exists, _ = cache.Get("key1")
        if exists </span><span class="cov0" title="0">{
                t.Log("过期条目可能已被清理")
        }</span>
}

func TestConnectionPool_GetStats(t *testing.T) <span class="cov0" title="0">{
        pool := NewConnectionPool(10)
        
        stats := pool.GetStats()
        if stats.ActiveConnections != 0 </span><span class="cov0" title="0">{
                t.Errorf("期望0个活动连接，实际%d", stats.ActiveConnections)
        }</span>
        
        <span class="cov0" title="0">if stats.TotalConnections != 0 </span><span class="cov0" title="0">{
                t.Errorf("期望0个总连接，实际%d", stats.TotalConnections)
        }</span>
}

</pre>
		
		<pre class="file" id="file14" style="display: none">package ratelimiter

import (
        "context"
        "sync"
        "time"
)

// RateLimiter 令牌桶速率限制器
type RateLimiter struct {
        mu            sync.Mutex
        tokens        float64       // 当前令牌数
        maxTokens     float64       // 最大令牌数
        rate          float64       // 每秒生成的令牌数
        lastUpdate    time.Time     // 上次更新时间
        burstSize     int           // 突发大小（允许的突发请求数）
        perMessage    bool          // 是否按消息计数（true）或按字节计数（false）
        bytesPerToken float64       // 每个令牌对应的字节数（当perMessage=false时使用）
}

// NewRateLimiter 创建新的速率限制器
// rate: 速率限制（消息/秒 或 字节/秒）
// burst: 突发大小（允许的突发数量）
// perMessage: true表示按消息计数，false表示按字节计数
func NewRateLimiter(rate float64, burst int, perMessage bool) *RateLimiter <span class="cov8" title="1">{
        if rate &lt;= 0 </span><span class="cov0" title="0">{
                // 如果速率为0或负数，表示不限制
                return nil
        }</span>

        <span class="cov8" title="1">rl := &amp;RateLimiter{
                tokens:     float64(burst),
                maxTokens:  float64(burst),
                rate:       rate,
                lastUpdate: time.Now(),
                burstSize:  burst,
                perMessage: perMessage,
        }

        if !perMessage </span><span class="cov8" title="1">{
                // 按字节计数，每个令牌对应1字节
                rl.bytesPerToken = 1.0
        }</span>

        <span class="cov8" title="1">return rl</span>
}

// NewBytesRateLimiter 创建字节速率限制器
// rate: 字节/秒
// burst: 突发字节数
func NewBytesRateLimiter(rate float64, burst int) *RateLimiter <span class="cov8" title="1">{
        return NewRateLimiter(rate, burst, false)
}</span>

// Wait 等待直到有足够的令牌可用
// 如果限制器为nil（不限制），则立即返回
func (rl *RateLimiter) Wait(ctx context.Context) error <span class="cov8" title="1">{
        if rl == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">rl.mu.Lock()
        defer rl.mu.Unlock()

        // 更新令牌数
        rl.updateTokens()

        // 如果令牌足够，消耗一个令牌
        if rl.tokens &gt;= 1.0 </span><span class="cov8" title="1">{
                rl.tokens -= 1.0
                return nil
        }</span>

        // 计算需要等待的时间
        <span class="cov8" title="1">needed := 1.0 - rl.tokens
        waitTime := time.Duration(float64(time.Second) * needed / rl.rate)

        // 等待直到有令牌可用
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        case &lt;-time.After(waitTime):<span class="cov8" title="1">
                // 更新令牌数
                rl.updateTokens()
                if rl.tokens &gt;= 1.0 </span><span class="cov8" title="1">{
                        rl.tokens -= 1.0
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

// WaitN 等待直到有N个令牌可用
func (rl *RateLimiter) WaitN(ctx context.Context, n int) error <span class="cov8" title="1">{
        if rl == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if n &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">rl.mu.Lock()
        defer rl.mu.Unlock()

        // 更新令牌数
        rl.updateTokens()

        // 如果令牌足够，消耗N个令牌
        if rl.tokens &gt;= float64(n) </span><span class="cov8" title="1">{
                rl.tokens -= float64(n)
                return nil
        }</span>

        // 计算需要等待的时间
        <span class="cov8" title="1">needed := float64(n) - rl.tokens
        waitTime := time.Duration(float64(time.Second) * needed / rl.rate)

        // 等待直到有足够的令牌
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        case &lt;-time.After(waitTime):<span class="cov8" title="1">
                // 更新令牌数
                rl.updateTokens()
                if rl.tokens &gt;= float64(n) </span><span class="cov0" title="0">{
                        rl.tokens -= float64(n)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

// WaitBytes 等待直到有足够的字节令牌可用
func (rl *RateLimiter) WaitBytes(ctx context.Context, bytes int) error <span class="cov8" title="1">{
        if rl == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if bytes &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">rl.mu.Lock()
        defer rl.mu.Unlock()

        // 更新令牌数
        rl.updateTokens()

        // 计算需要的令牌数
        neededTokens := float64(bytes) * rl.bytesPerToken

        // 如果令牌足够，消耗相应数量的令牌
        if rl.tokens &gt;= neededTokens </span><span class="cov8" title="1">{
                rl.tokens -= neededTokens
                return nil
        }</span>

        // 计算需要等待的时间
        <span class="cov8" title="1">needed := neededTokens - rl.tokens
        waitTime := time.Duration(float64(time.Second) * needed / rl.rate)

        // 等待直到有足够的令牌
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        case &lt;-time.After(waitTime):<span class="cov8" title="1">
                // 更新令牌数
                rl.updateTokens()
                if rl.tokens &gt;= neededTokens </span><span class="cov8" title="1">{
                        rl.tokens -= neededTokens
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

// Allow 检查是否有足够的令牌（不等待）
func (rl *RateLimiter) Allow() bool <span class="cov8" title="1">{
        if rl == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">rl.mu.Lock()
        defer rl.mu.Unlock()

        rl.updateTokens()

        if rl.tokens &gt;= 1.0 </span><span class="cov8" title="1">{
                rl.tokens -= 1.0
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// AllowN 检查是否有N个令牌可用（不等待）
func (rl *RateLimiter) AllowN(n int) bool <span class="cov8" title="1">{
        if rl == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if n &lt;= 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">rl.mu.Lock()
        defer rl.mu.Unlock()

        rl.updateTokens()

        if rl.tokens &gt;= float64(n) </span><span class="cov8" title="1">{
                rl.tokens -= float64(n)
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// AllowBytes 检查是否有足够的字节令牌可用（不等待）
func (rl *RateLimiter) AllowBytes(bytes int) bool <span class="cov0" title="0">{
        if rl == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if bytes &lt;= 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">rl.mu.Lock()
        defer rl.mu.Unlock()

        rl.updateTokens()

        neededTokens := float64(bytes) * rl.bytesPerToken
        if rl.tokens &gt;= neededTokens </span><span class="cov0" title="0">{
                rl.tokens -= neededTokens
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// updateTokens 更新令牌数（需要先获取锁）
func (rl *RateLimiter) updateTokens() <span class="cov8" title="1">{
        now := time.Now()
        elapsed := now.Sub(rl.lastUpdate).Seconds()

        // 计算新增的令牌数
        newTokens := elapsed * rl.rate

        // 更新令牌数（不超过最大值）
        rl.tokens = min(rl.tokens+newTokens, rl.maxTokens)
        rl.lastUpdate = now
}</span>

// SetRate 动态设置速率
func (rl *RateLimiter) SetRate(rate float64) <span class="cov8" title="1">{
        if rl == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">rl.mu.Lock()
        defer rl.mu.Unlock()

        rl.updateTokens()
        rl.rate = rate</span>
}

// GetRate 获取当前速率
func (rl *RateLimiter) GetRate() float64 <span class="cov8" title="1">{
        if rl == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">rl.mu.Lock()
        defer rl.mu.Unlock()

        return rl.rate</span>
}

// min 返回两个float64中的较小值
func min(a, b float64) float64 <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package ratelimiter

import (
        "context"
        "testing"
)

func TestRateLimiter_NilCases(t *testing.T) <span class="cov0" title="0">{
        // 测试nil限流器的各种方法
        var limiter *RateLimiter = nil
        ctx := context.Background()
        
        // Wait应该不阻塞
        if err := limiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                t.Errorf("nil限流器Wait应该不返回错误: %v", err)
        }</span>
        
        // WaitN应该不阻塞
        <span class="cov0" title="0">if err := limiter.WaitN(ctx, 10); err != nil </span><span class="cov0" title="0">{
                t.Errorf("nil限流器WaitN应该不返回错误: %v", err)
        }</span>
        
        // WaitBytes应该不阻塞
        <span class="cov0" title="0">if err := limiter.WaitBytes(ctx, 1000); err != nil </span><span class="cov0" title="0">{
                t.Errorf("nil限流器WaitBytes应该不返回错误: %v", err)
        }</span>
        
        // Allow应该总是返回true
        <span class="cov0" title="0">if !limiter.Allow() </span><span class="cov0" title="0">{
                t.Error("nil限流器Allow应该返回true")
        }</span>
        
        // AllowN应该总是返回true
        <span class="cov0" title="0">if !limiter.AllowN(10) </span><span class="cov0" title="0">{
                t.Error("nil限流器AllowN应该返回true")
        }</span>
        
        // AllowBytes应该总是返回true
        <span class="cov0" title="0">if !limiter.AllowBytes(1000) </span><span class="cov0" title="0">{
                t.Error("nil限流器AllowBytes应该返回true")
        }</span>
        
        // SetRate应该不panic
        <span class="cov0" title="0">limiter.SetRate(100.0)
        
        // GetRate应该返回0
        if limiter.GetRate() != 0 </span><span class="cov0" title="0">{
                t.Errorf("nil限流器GetRate应该返回0，实际%f", limiter.GetRate())
        }</span>
}

func TestRateLimiter_ZeroRate(t *testing.T) <span class="cov0" title="0">{
        // 测试速率为0的情况（应该返回nil）
        limiter := NewRateLimiter(0.0, 10, true)
        if limiter != nil </span><span class="cov0" title="0">{
                t.Error("速率为0时应该返回nil")
        }</span>
        
        <span class="cov0" title="0">limiter = NewRateLimiter(-1.0, 10, true)
        if limiter != nil </span><span class="cov0" title="0">{
                t.Error("速率为负数时应该返回nil")
        }</span>
}

func TestRateLimiter_ContextCancellation(t *testing.T) <span class="cov0" title="0">{
        limiter := NewRateLimiter(1.0, 1, true)
        ctx, cancel := context.WithCancel(context.Background())
        
        // 立即取消上下文
        cancel()
        
        // 应该返回上下文取消错误
        err := limiter.Wait(ctx)
        if err == nil </span><span class="cov0" title="0">{
                t.Error("应该返回上下文取消错误")
        }</span>
        
        <span class="cov0" title="0">if err != context.Canceled </span><span class="cov0" title="0">{
                t.Errorf("期望context.Canceled错误，实际%v", err)
        }</span>
}

func TestRateLimiter_AllowBytes(t *testing.T) <span class="cov0" title="0">{
        limiter := NewBytesRateLimiter(1024.0, 1024)
        
        // 第一次应该允许
        if !limiter.AllowBytes(512) </span><span class="cov0" title="0">{
                t.Error("应该允许512字节")
        }</span>
        
        // 再获取512字节应该允许（在突发范围内）
        <span class="cov0" title="0">if !limiter.AllowBytes(512) </span><span class="cov0" title="0">{
                t.Error("应该允许剩余的512字节")
        }</span>
        
        // 再获取1字节应该被拒绝（超过突发）
        <span class="cov0" title="0">if limiter.AllowBytes(1) </span><span class="cov0" title="0">{
                t.Error("应该拒绝（超过突发大小）")
        }</span>
}

func TestRateLimiter_GetRate(t *testing.T) <span class="cov0" title="0">{
        limiter := NewRateLimiter(100.0, 10, true)
        
        rate := limiter.GetRate()
        if rate != 100.0 </span><span class="cov0" title="0">{
                t.Errorf("期望速率100.0，实际%f", rate)
        }</span>
        
        // 设置新速率
        <span class="cov0" title="0">limiter.SetRate(200.0)
        rate = limiter.GetRate()
        if rate != 200.0 </span><span class="cov0" title="0">{
                t.Errorf("期望速率200.0，实际%f", rate)
        }</span>
}

</pre>
		
		<pre class="file" id="file16" style="display: none">package retry

import (
        "context"
        "fmt"
        "math"
        "sync"
        "time"
)

// RetryConfigInternal 重试配置（内部使用）
type RetryConfigInternal struct {
        MaxRetries      int           // 最大重试次数
        InitialInterval time.Duration // 初始重试间隔
        MaxInterval     time.Duration // 最大重试间隔
        Multiplier      float64       // 退避倍数（指数退避）
        Jitter          bool          // 是否添加随机抖动
}

// DefaultRetryConfig 默认重试配置
func DefaultRetryConfig() *RetryConfigInternal <span class="cov8" title="1">{
        return &amp;RetryConfigInternal{
                MaxRetries:      3,
                InitialInterval: 100 * time.Millisecond,
                MaxInterval:     10 * time.Second,
                Multiplier:      2.0,
                Jitter:          true,
        }
}</span>

// RetryManager 重试管理器
type RetryManager struct {
        config *RetryConfigInternal
        mu     sync.RWMutex
}

// NewRetryManager 创建新的重试管理器
func NewRetryManager(config *RetryConfigInternal) *RetryManager <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = DefaultRetryConfig()
        }</span>
        <span class="cov8" title="1">return &amp;RetryManager{
                config: config,
        }</span>
}

// Retry 执行重试操作
func (rm *RetryManager) Retry(ctx context.Context, fn func() error) error <span class="cov8" title="1">{
        rm.mu.RLock()
        maxRetries := rm.config.MaxRetries
        initialInterval := rm.config.InitialInterval
        maxInterval := rm.config.MaxInterval
        multiplier := rm.config.Multiplier
        jitter := rm.config.Jitter
        rm.mu.RUnlock()

        var lastErr error
        interval := initialInterval

        for attempt := 0; attempt &lt;= maxRetries; attempt++ </span><span class="cov8" title="1">{
                // 尝试执行操作
                err := fn()
                if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">lastErr = err

                // 如果是最后一次尝试，返回错误
                if attempt &gt;= maxRetries </span><span class="cov8" title="1">{
                        break</span>
                }

                // 检查上下文是否已取消
                <span class="cov8" title="1">select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return fmt.Errorf("context cancelled: %w", ctx.Err())</span>
                default:<span class="cov8" title="1"></span>
                }

                // 计算下次重试的间隔（指数退避）
                <span class="cov8" title="1">if attempt &lt; maxRetries </span><span class="cov8" title="1">{
                        // 指数退避
                        nextInterval := time.Duration(float64(interval) * multiplier)

                        // 限制最大间隔
                        if nextInterval &gt; maxInterval </span><span class="cov0" title="0">{
                                nextInterval = maxInterval
                        }</span>

                        // 添加抖动（可选）
                        <span class="cov8" title="1">if jitter </span><span class="cov8" title="1">{
                                nextInterval = addJitter(nextInterval)
                        }</span>

                        // 等待重试间隔
                        <span class="cov8" title="1">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return fmt.Errorf("context cancelled: %w", ctx.Err())</span>
                        case &lt;-time.After(interval):<span class="cov8" title="1">
                                interval = nextInterval</span>
                        }
                }
        }

        <span class="cov8" title="1">return fmt.Errorf("max retries exceeded: %w", lastErr)</span>
}

// RetryWithBackoff 执行带退避的重试（自定义重试逻辑）
func (rm *RetryManager) RetryWithBackoff(ctx context.Context, fn func(attempt int) error) error <span class="cov0" title="0">{
        rm.mu.RLock()
        maxRetries := rm.config.MaxRetries
        initialInterval := rm.config.InitialInterval
        maxInterval := rm.config.MaxInterval
        multiplier := rm.config.Multiplier
        jitter := rm.config.Jitter
        rm.mu.RUnlock()

        var lastErr error
        interval := initialInterval

        for attempt := 0; attempt &lt;= maxRetries; attempt++ </span><span class="cov0" title="0">{
                // 尝试执行操作
                err := fn(attempt)
                if err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">lastErr = err

                // 如果是最后一次尝试，返回错误
                if attempt &gt;= maxRetries </span><span class="cov0" title="0">{
                        break</span>
                }

                // 检查上下文是否已取消
                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("context cancelled: %w", ctx.Err())</span>
                default:<span class="cov0" title="0"></span>
                }

                // 计算下次重试的间隔
                <span class="cov0" title="0">nextInterval := time.Duration(float64(interval) * multiplier)
                if nextInterval &gt; maxInterval </span><span class="cov0" title="0">{
                        nextInterval = maxInterval
                }</span>

                <span class="cov0" title="0">if jitter </span><span class="cov0" title="0">{
                        nextInterval = addJitter(nextInterval)
                }</span>

                // 等待重试间隔
                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("context cancelled: %w", ctx.Err())</span>
                case &lt;-time.After(interval):<span class="cov0" title="0">
                        interval = nextInterval</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("max retries exceeded: %w", lastErr)</span>
}

// addJitter 添加随机抖动（±25%）
func addJitter(interval time.Duration) time.Duration <span class="cov8" title="1">{
        jitter := time.Duration(float64(interval) * 0.25)
        jitterAmount := time.Duration(float64(jitter) * (math.Mod(float64(time.Now().UnixNano()), 2.0) - 0.5))
        return interval + jitterAmount
}</span>

// SetConfig 更新重试配置
func (rm *RetryManager) SetConfig(config *RetryConfigInternal) <span class="cov0" title="0">{
        rm.mu.Lock()
        defer rm.mu.Unlock()
        rm.config = config
}</span>

// GetConfig 获取当前重试配置
func (rm *RetryManager) GetConfig() *RetryConfigInternal <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()
        return rm.config
}</span>

</pre>
		
		<pre class="file" id="file17" style="display: none">package security

import (
        "crypto/tls"
        "crypto/x509"
        "fmt"
        "log"
        "os"
)

// TLSConfig TLS配置
type TLSConfig struct {
        Enabled            bool   `mapstructure:"enabled"`
        CertFile           string `mapstructure:"cert_file"`
        KeyFile            string `mapstructure:"key_file"`
        CAFile             string `mapstructure:"ca_file"`
        InsecureSkipVerify bool   `mapstructure:"insecure_skip_verify"`
        MinVersion         string `mapstructure:"min_version"`
        MaxVersion         string `mapstructure:"max_version"`
}

// NewTLSConfig 创建TLS配置
func NewTLSConfig(config *TLSConfig) (*tls.Config, error) <span class="cov8" title="1">{
        if !config.Enabled </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        
        <span class="cov8" title="1">tlsConfig := &amp;tls.Config{
                InsecureSkipVerify: config.InsecureSkipVerify,
        }
        
        // 加载客户端证书（如果提供）
        if config.CertFile != "" &amp;&amp; config.KeyFile != "" </span><span class="cov0" title="0">{
                cert, err := tls.LoadX509KeyPair(config.CertFile, config.KeyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("加载TLS证书失败: %w", err)
                }</span>
                <span class="cov0" title="0">tlsConfig.Certificates = []tls.Certificate{cert}</span>
        }
        
        // 加载CA证书（如果提供）
        <span class="cov8" title="1">if config.CAFile != "" </span><span class="cov0" title="0">{
                caCert, err := os.ReadFile(config.CAFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("读取CA证书失败: %w", err)
                }</span>
                
                <span class="cov0" title="0">caCertPool := x509.NewCertPool()
                if !caCertPool.AppendCertsFromPEM(caCert) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("解析CA证书失败")
                }</span>
                <span class="cov0" title="0">tlsConfig.RootCAs = caCertPool</span>
        }
        
        // 设置TLS版本
        <span class="cov8" title="1">if config.MinVersion != "" </span><span class="cov8" title="1">{
                version, err := parseTLSVersion(config.MinVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("无效的TLS最小版本: %w", err)
                }</span>
                <span class="cov8" title="1">tlsConfig.MinVersion = version</span>
        }
        
        <span class="cov8" title="1">if config.MaxVersion != "" </span><span class="cov0" title="0">{
                version, err := parseTLSVersion(config.MaxVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("无效的TLS最大版本: %w", err)
                }</span>
                <span class="cov0" title="0">tlsConfig.MaxVersion = version</span>
        }
        
        <span class="cov8" title="1">return tlsConfig, nil</span>
}

// parseTLSVersion 解析TLS版本字符串
func parseTLSVersion(version string) (uint16, error) <span class="cov8" title="1">{
        switch version </span>{
        case "1.0":<span class="cov8" title="1">
                return tls.VersionTLS10, nil</span>
        case "1.1":<span class="cov8" title="1">
                return tls.VersionTLS11, nil</span>
        case "1.2":<span class="cov8" title="1">
                return tls.VersionTLS12, nil</span>
        case "1.3":<span class="cov8" title="1">
                return tls.VersionTLS13, nil</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("不支持的TLS版本: %s", version)</span>
        }
}

// ConfigEncryption 配置加密（用于敏感信息）
type ConfigEncryption struct {
        enabled bool
        key     []byte
}

// NewConfigEncryption 创建配置加密器
func NewConfigEncryption(enabled bool, key []byte) *ConfigEncryption <span class="cov8" title="1">{
        return &amp;ConfigEncryption{
                enabled: enabled,
                key:     key,
        }
}</span>

// Encrypt 加密敏感配置值（简单实现，生产环境应使用更安全的方案）
func (ce *ConfigEncryption) Encrypt(value string) (string, error) <span class="cov8" title="1">{
        if !ce.enabled </span><span class="cov8" title="1">{
                return value, nil
        }</span>
        
        // 这里实现简单的XOR加密（仅示例，生产环境应使用AES等）
        <span class="cov8" title="1">encrypted := make([]byte, len(value))
        for i := 0; i &lt; len(value); i++ </span><span class="cov8" title="1">{
                encrypted[i] = value[i] ^ ce.key[i%len(ce.key)]
        }</span>
        
        // Base64编码（实际应该使用更安全的编码）
        <span class="cov8" title="1">return fmt.Sprintf("encrypted:%x", encrypted), nil</span>
}

// Decrypt 解密配置值
func (ce *ConfigEncryption) Decrypt(encrypted string) (string, error) <span class="cov0" title="0">{
        if !ce.enabled </span><span class="cov0" title="0">{
                return encrypted, nil
        }</span>
        
        // 这里应该实现对应的解密逻辑
        // 仅示例，生产环境需要完整实现
        <span class="cov0" title="0">return encrypted, nil</span>
}

// SecurityAudit 安全审计日志
type SecurityAudit struct {
        enabled bool
}

// NewSecurityAudit 创建安全审计
func NewSecurityAudit(enabled bool) *SecurityAudit <span class="cov8" title="1">{
        return &amp;SecurityAudit{
                enabled: enabled,
        }
}</span>

// LogAccess 记录访问日志
func (sa *SecurityAudit) LogAccess(action string, resource string, success bool) <span class="cov8" title="1">{
        if !sa.enabled </span><span class="cov8" title="1">{
                return
        }</span>
        
        <span class="cov8" title="1">status := "success"
        if !success </span><span class="cov8" title="1">{
                status = "failed"
        }</span>
        
        <span class="cov8" title="1">log.Printf("[安全审计] action=%s resource=%s status=%s", action, resource, status)</span>
}

// LogConfigChange 记录配置变更
func (sa *SecurityAudit) LogConfigChange(key string, oldValue string, newValue string) <span class="cov8" title="1">{
        if !sa.enabled </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov8" title="1">log.Printf("[安全审计] config_change key=%s old_value=%s new_value=%s", key, oldValue, newValue)</span>
}

</pre>
		
		<pre class="file" id="file18" style="display: none">package version

import (
        "bufio"
        "os"
        "strings"
)

var (
        // Version 版本号，通过VERSION文件读取
        Version = "0.1.1"
        // BuildTime 构建时间，编译时注入
        BuildTime = "unknown"
        // GitCommit Git提交哈希，编译时注入
        GitCommit = "unknown"
)

func init() <span class="cov0" title="0">{
        // 尝试从VERSION文件读取版本号
        if versionFile, err := os.Open("VERSION"); err == nil </span><span class="cov0" title="0">{
                defer versionFile.Close()
                scanner := bufio.NewScanner(versionFile)
                if scanner.Scan() </span><span class="cov0" title="0">{
                        version := strings.TrimSpace(scanner.Text())
                        if version != "" </span><span class="cov0" title="0">{
                                Version = version
                        }</span>
                }
        }
}

</pre>
		
		<pre class="file" id="file19" style="display: none">package plugins

import (
        "context"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/fsnotify/fsnotify"
)

// FilePlugin 文件监控数据源插件
type FilePlugin struct {
        config     *FilePluginConfig
        watcher    *fsnotify.Watcher
        msgChan    chan *Message
        stats      *FilePluginStats
        statsMu    sync.RWMutex
        ctx        context.Context
        cancel     context.CancelFunc
        wg         sync.WaitGroup
        processedFiles map[string]bool
        processedMu    sync.RWMutex
}

// FilePluginConfig 文件插件配置
type FilePluginConfig struct {
        WatchDir      string
        FinishDir     string
        FilePattern   string // 文件匹配模式，如 "*.txt", "*.json"
        PollInterval  time.Duration
        Recursive     bool // 是否递归监控子目录
}

// FilePluginStats 文件插件统计信息
type FilePluginStats struct {
        MessagesReceived int64
        MessagesAcked    int64
        Errors           int64
        FilesProcessed   int64
        LastMessageTime  time.Time
        StartTime        time.Time
}

// NewFilePlugin 创建文件插件实例
func NewFilePlugin() SourcePlugin <span class="cov8" title="1">{
        return &amp;FilePlugin{
                stats: &amp;FilePluginStats{
                        StartTime: time.Now(),
                },
                processedFiles: make(map[string]bool),
        }
}</span>

// Name 返回插件名称
func (p *FilePlugin) Name() string <span class="cov8" title="1">{
        return "file"
}</span>

// Initialize 初始化插件
func (p *FilePlugin) Initialize(config map[string]interface{}) error <span class="cov8" title="1">{
        cfg := &amp;FilePluginConfig{}

        if watchDir, ok := config["watch_dir"].(string); ok </span><span class="cov8" title="1">{
                cfg.WatchDir = watchDir
        }</span> else<span class="cov0" title="0"> {
                return fmt.Errorf("watch_dir配置不能为空")
        }</span>

        <span class="cov8" title="1">if finishDir, ok := config["finish_dir"].(string); ok </span><span class="cov8" title="1">{
                cfg.FinishDir = finishDir
        }</span> else<span class="cov0" title="0"> {
                return fmt.Errorf("finish_dir配置不能为空")
        }</span>

        <span class="cov8" title="1">if filePattern, ok := config["file_pattern"].(string); ok </span><span class="cov8" title="1">{
                cfg.FilePattern = filePattern
        }</span> else<span class="cov0" title="0"> {
                cfg.FilePattern = "*" // 默认匹配所有文件
        }</span>

        <span class="cov8" title="1">if pollInterval, ok := config["poll_interval"].(time.Duration); ok </span><span class="cov8" title="1">{
                cfg.PollInterval = pollInterval
        }</span> else<span class="cov8" title="1"> {
                cfg.PollInterval = 1 * time.Second
        }</span>

        <span class="cov8" title="1">if recursive, ok := config["recursive"].(bool); ok </span><span class="cov8" title="1">{
                cfg.Recursive = recursive
        }</span> else<span class="cov8" title="1"> {
                cfg.Recursive = false
        }</span>

        <span class="cov8" title="1">p.config = cfg
        p.msgChan = make(chan *Message, 100)

        // 确保目录存在
        if err := os.MkdirAll(cfg.WatchDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("创建监控目录失败: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.MkdirAll(cfg.FinishDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("创建完成目录失败: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Start 启动插件
func (p *FilePlugin) Start(ctx context.Context) error <span class="cov8" title="1">{
        p.ctx, p.cancel = context.WithCancel(ctx)

        // 创建文件监控器
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("创建文件监控器失败: %w", err)
        }</span>
        <span class="cov8" title="1">p.watcher = watcher

        // 添加监控目录
        if p.config.Recursive </span><span class="cov0" title="0">{
                err = filepath.Walk(p.config.WatchDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                                return watcher.Add(path)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
        } else<span class="cov8" title="1"> {
                err = watcher.Add(p.config.WatchDir)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                watcher.Close()
                return fmt.Errorf("添加监控目录失败: %w", err)
        }</span>

        <span class="cov8" title="1">log.Printf("[文件插件] 开始监控目录: %s (模式: %s)", p.config.WatchDir, p.config.FilePattern)

        // 处理文件系统事件
        p.wg.Add(1)
        go p.watchEvents()

        // 初始扫描已存在的文件
        p.wg.Add(1)
        go p.scanExistingFiles()

        return nil</span>
}

// watchEvents 监控文件系统事件
func (p *FilePlugin) watchEvents() <span class="cov8" title="1">{
        defer p.wg.Done()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-p.ctx.Done():<span class="cov8" title="1">
                        return</span>

                case event, ok := &lt;-p.watcher.Events:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        // 只处理文件写入完成事件
                        <span class="cov0" title="0">if event.Op&amp;fsnotify.Write == fsnotify.Write || event.Op&amp;fsnotify.Create == fsnotify.Create </span><span class="cov0" title="0">{
                                // 检查文件是否匹配模式
                                if p.matchesPattern(event.Name) </span><span class="cov0" title="0">{
                                        p.processFile(event.Name)
                                }</span>
                        }

                case err, ok := &lt;-p.watcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">log.Printf("[文件插件] 监控错误: %v", err)
                        p.statsMu.Lock()
                        p.stats.Errors++
                        p.statsMu.Unlock()</span>
                }
        }
}

// scanExistingFiles 扫描已存在的文件
func (p *FilePlugin) scanExistingFiles() <span class="cov8" title="1">{
        defer p.wg.Done()

        ticker := time.NewTicker(p.config.PollInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-p.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        p.scanDirectory(p.config.WatchDir)</span>
                }
        }
}

// scanDirectory 扫描目录中的文件
func (p *FilePlugin) scanDirectory(dir string) <span class="cov8" title="1">{
        err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">if !info.IsDir() &amp;&amp; p.matchesPattern(path) </span><span class="cov8" title="1">{
                        p.processFile(path)
                }</span>

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                log.Printf("[文件插件] 扫描目录错误: %v", err)
        }</span>
}

// matchesPattern 检查文件是否匹配模式
func (p *FilePlugin) matchesPattern(filename string) bool <span class="cov8" title="1">{
        if p.config.FilePattern == "*" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">matched, err := filepath.Match(p.config.FilePattern, filepath.Base(filename))
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return matched</span>
}

// processFile 处理文件
func (p *FilePlugin) processFile(filePath string) <span class="cov8" title="1">{
        // 检查是否已处理
        p.processedMu.RLock()
        if p.processedFiles[filePath] </span><span class="cov8" title="1">{
                p.processedMu.RUnlock()
                return
        }</span>
        <span class="cov8" title="1">p.processedMu.RUnlock()

        // 读取文件内容
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[文件插件] 读取文件失败 %s: %v", filePath, err)
                p.statsMu.Lock()
                p.stats.Errors++
                p.statsMu.Unlock()
                return
        }</span>

        // 标记为已处理
        <span class="cov8" title="1">p.processedMu.Lock()
        p.processedFiles[filePath] = true
        p.processedMu.Unlock()

        // 创建消息
        msg := &amp;Message{
                Key:       []byte(filepath.Base(filePath)),
                Value:     content,
                Headers:   make(map[string][]byte),
                Timestamp: time.Now(),
                Source:    "file",
                Metadata: map[string]interface{}{
                        "file_path": filePath,
                        "file_name": filepath.Base(filePath),
                        "file_size": len(content),
                },
        }

        // 更新统计
        p.statsMu.Lock()
        p.stats.MessagesReceived++
        p.stats.LastMessageTime = time.Now()
        p.statsMu.Unlock()

        // 发送消息
        select </span>{
        case p.msgChan &lt;- msg:<span class="cov8" title="1"></span>
        case &lt;-p.ctx.Done():<span class="cov0" title="0">
                return</span>
        }
}

// moveToFinishDir 移动文件到完成目录
func (p *FilePlugin) moveToFinishDir(filePath string) error <span class="cov8" title="1">{
        fileName := filepath.Base(filePath)
        finishPath := filepath.Join(p.config.FinishDir, fileName)

        // 如果目标文件已存在，添加时间戳
        if _, err := os.Stat(finishPath); err == nil </span><span class="cov0" title="0">{
                ext := filepath.Ext(fileName)
                name := strings.TrimSuffix(fileName, ext)
                finishPath = filepath.Join(p.config.FinishDir, fmt.Sprintf("%s_%d%s", name, time.Now().Unix(), ext))
        }</span>

        <span class="cov8" title="1">err := os.Rename(filePath, finishPath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("移动文件失败: %w", err)
        }</span>

        <span class="cov0" title="0">p.statsMu.Lock()
        p.stats.FilesProcessed++
        p.statsMu.Unlock()

        log.Printf("[文件插件] 文件已移动到完成目录: %s -&gt; %s", filePath, finishPath)
        return nil</span>
}

// Stop 停止插件
func (p *FilePlugin) Stop() error <span class="cov8" title="1">{
        if p.cancel != nil </span><span class="cov8" title="1">{
                p.cancel()
        }</span>
        <span class="cov8" title="1">if p.watcher != nil </span><span class="cov8" title="1">{
                p.watcher.Close()
        }</span>
        <span class="cov8" title="1">p.wg.Wait()
        if p.msgChan != nil </span><span class="cov8" title="1">{
                close(p.msgChan)
        }</span>
        <span class="cov8" title="1">log.Println("[文件插件] 已停止")
        return nil</span>
}

// Messages 返回消息通道
func (p *FilePlugin) Messages() &lt;-chan *Message <span class="cov8" title="1">{
        return p.msgChan
}</span>

// Ack 确认消息（处理后移动文件）
func (p *FilePlugin) Ack(msg *Message) error <span class="cov8" title="1">{
        if filePath, ok := msg.Metadata["file_path"].(string); ok </span><span class="cov8" title="1">{
                err := p.moveToFinishDir(filePath)
                if err != nil </span><span class="cov8" title="1">{
                        p.statsMu.Lock()
                        p.stats.Errors++
                        p.statsMu.Unlock()
                        return err
                }</span>

                // 从已处理列表中移除
                <span class="cov0" title="0">p.processedMu.Lock()
                delete(p.processedFiles, filePath)
                p.processedMu.Unlock()

                p.statsMu.Lock()
                p.stats.MessagesAcked++
                p.statsMu.Unlock()</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetStats 获取统计信息
func (p *FilePlugin) GetStats() PluginStats <span class="cov8" title="1">{
        p.statsMu.RLock()
        defer p.statsMu.RUnlock()

        return PluginStats{
                MessagesReceived: p.stats.MessagesReceived,
                MessagesAcked:    p.stats.MessagesAcked,
                Errors:           p.stats.Errors,
                LastMessageTime:  p.stats.LastMessageTime,
                StartTime:        p.stats.StartTime,
        }
}</span>

func init() <span class="cov8" title="1">{
        RegisterPlugin("file", NewFilePlugin)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package plugins

import (
        "context"
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/IBM/sarama"
        
        "message-mirror/internal/pkg/security"
)

// KafkaPlugin Kafka数据源插件
type KafkaPlugin struct {
        config     *KafkaPluginConfig
        consumer   sarama.ConsumerGroup
        msgChan    chan *Message
        handler    *kafkaConsumerGroupHandler
        stats      *KafkaPluginStats
        statsMu    sync.RWMutex
}

// KafkaPluginConfig Kafka插件配置
type KafkaPluginConfig struct {
        Brokers          []string
        Topic            string
        Topics           []string
        GroupID          string
        AutoOffsetReset  string
        SessionTimeout   time.Duration
        BatchSize        int
        SecurityProtocol string
        SASLUsername     string
        SASLPassword     string
}

// KafkaPluginStats Kafka插件统计信息
type KafkaPluginStats struct {
        MessagesReceived int64
        MessagesAcked    int64
        Errors           int64
        LastMessageTime  time.Time
        StartTime        time.Time
}

// kafkaConsumerGroupHandler Kafka消费者组处理器
type kafkaConsumerGroupHandler struct {
        msgChan chan *Message
        stats   *KafkaPluginStats
        statsMu *sync.RWMutex
}

func (h *kafkaConsumerGroupHandler) Setup(sarama.ConsumerGroupSession) error <span class="cov0" title="0">{
        return nil
}</span>

func (h *kafkaConsumerGroupHandler) Cleanup(sarama.ConsumerGroupSession) error <span class="cov0" title="0">{
        return nil
}</span>

func (h *kafkaConsumerGroupHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case message := &lt;-claim.Messages():<span class="cov0" title="0">
                        if message == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        // 转换为统一消息格式
                        <span class="cov0" title="0">msg := &amp;Message{
                                Key:       message.Key,
                                Value:     message.Value,
                                Headers:   convertKafkaHeaders(message.Headers),
                                Timestamp: message.Timestamp,
                                Source:    "kafka",
                                Metadata: map[string]interface{}{
                                        "topic":     message.Topic,
                                        "partition": message.Partition,
                                        "offset":    message.Offset,
                                },
                        }

                        // 更新统计
                        h.statsMu.Lock()
                        h.stats.MessagesReceived++
                        h.stats.LastMessageTime = time.Now()
                        h.statsMu.Unlock()

                        // 发送消息
                        select </span>{
                        case h.msgChan &lt;- msg:<span class="cov0" title="0">
                                session.MarkMessage(message, "")</span>
                        case &lt;-session.Context().Done():<span class="cov0" title="0">
                                return nil</span>
                        }

                case &lt;-session.Context().Done():<span class="cov0" title="0">
                        return nil</span>
                }
        }
}

// convertKafkaHeaders 转换Kafka消息头
func convertKafkaHeaders(headers []*sarama.RecordHeader) map[string][]byte <span class="cov0" title="0">{
        if len(headers) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make(map[string][]byte, len(headers))
        for _, h := range headers </span><span class="cov0" title="0">{
                result[string(h.Key)] = h.Value
        }</span>
        <span class="cov0" title="0">return result</span>
}

// NewKafkaPlugin 创建Kafka插件实例
func NewKafkaPlugin() SourcePlugin <span class="cov8" title="1">{
        return &amp;KafkaPlugin{
                stats: &amp;KafkaPluginStats{
                        StartTime: time.Now(),
                },
        }
}</span>

// Name 返回插件名称
func (p *KafkaPlugin) Name() string <span class="cov8" title="1">{
        return "kafka"
}</span>

// Initialize 初始化插件
func (p *KafkaPlugin) Initialize(config map[string]interface{}) error <span class="cov8" title="1">{
        cfg := &amp;KafkaPluginConfig{}

        // 解析配置
        if brokers, ok := config["brokers"].([]interface{}); ok </span><span class="cov8" title="1">{
                cfg.Brokers = make([]string, len(brokers))
                for i, b := range brokers </span><span class="cov8" title="1">{
                        if s, ok := b.(string); ok </span><span class="cov8" title="1">{
                                cfg.Brokers[i] = s
                        }</span>
                }
        }

        <span class="cov8" title="1">if topic, ok := config["topic"].(string); ok </span><span class="cov8" title="1">{
                cfg.Topic = topic
        }</span>

        <span class="cov8" title="1">if topics, ok := config["topics"].([]interface{}); ok </span><span class="cov0" title="0">{
                cfg.Topics = make([]string, 0, len(topics))
                for _, t := range topics </span><span class="cov0" title="0">{
                        if s, ok := t.(string); ok </span><span class="cov0" title="0">{
                                cfg.Topics = append(cfg.Topics, s)
                        }</span>
                }
        }

        <span class="cov8" title="1">if groupID, ok := config["group_id"].(string); ok </span><span class="cov8" title="1">{
                cfg.GroupID = groupID
        }</span> else<span class="cov0" title="0"> {
                cfg.GroupID = "message-mirror-group"
        }</span>

        <span class="cov8" title="1">if autoOffsetReset, ok := config["auto_offset_reset"].(string); ok </span><span class="cov8" title="1">{
                cfg.AutoOffsetReset = autoOffsetReset
        }</span> else<span class="cov8" title="1"> {
                cfg.AutoOffsetReset = "earliest"
        }</span>

        <span class="cov8" title="1">if sessionTimeout, ok := config["session_timeout"].(time.Duration); ok </span><span class="cov8" title="1">{
                cfg.SessionTimeout = sessionTimeout
        }</span> else<span class="cov8" title="1"> {
                cfg.SessionTimeout = 30 * time.Second
        }</span>

        <span class="cov8" title="1">if batchSize, ok := config["batch_size"].(int); ok </span><span class="cov8" title="1">{
                cfg.BatchSize = batchSize
        }</span> else<span class="cov8" title="1"> {
                cfg.BatchSize = 100
        }</span>

        <span class="cov8" title="1">if securityProtocol, ok := config["security_protocol"].(string); ok </span><span class="cov8" title="1">{
                cfg.SecurityProtocol = securityProtocol
        }</span>

        <span class="cov8" title="1">if username, ok := config["sasl_username"].(string); ok </span><span class="cov0" title="0">{
                cfg.SASLUsername = username
        }</span>

        <span class="cov8" title="1">if password, ok := config["sasl_password"].(string); ok </span><span class="cov0" title="0">{
                cfg.SASLPassword = password
        }</span>

        <span class="cov8" title="1">p.config = cfg

        // 创建Sarama配置
        saramaConfig := sarama.NewConfig()
        saramaConfig.Version = sarama.V2_8_0_0
        saramaConfig.Consumer.Group.Rebalance.Strategy = sarama.NewBalanceStrategyRoundRobin()

        if cfg.AutoOffsetReset == "latest" </span><span class="cov0" title="0">{
                saramaConfig.Consumer.Offsets.Initial = sarama.OffsetNewest
        }</span> else<span class="cov8" title="1"> {
                saramaConfig.Consumer.Offsets.Initial = sarama.OffsetOldest
        }</span>

        <span class="cov8" title="1">saramaConfig.Consumer.Group.Session.Timeout = cfg.SessionTimeout
        saramaConfig.Consumer.Group.Heartbeat.Interval = 3 * time.Second
        saramaConfig.Consumer.Offsets.AutoCommit.Enable = true
        saramaConfig.Consumer.Offsets.AutoCommit.Interval = 1 * time.Second

        // TLS配置（从source配置中读取）
        if tlsConfig, ok := config["tls"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if enabled, ok := tlsConfig["enabled"].(bool); ok &amp;&amp; enabled </span><span class="cov0" title="0">{
                        tlsCfg := &amp;security.TLSConfig{
                                Enabled:            enabled,
                                InsecureSkipVerify: false,
                        }
                        
                        if certFile, ok := tlsConfig["cert_file"].(string); ok </span><span class="cov0" title="0">{
                                tlsCfg.CertFile = certFile
                        }</span>
                        <span class="cov0" title="0">if keyFile, ok := tlsConfig["key_file"].(string); ok </span><span class="cov0" title="0">{
                                tlsCfg.KeyFile = keyFile
                        }</span>
                        <span class="cov0" title="0">if caFile, ok := tlsConfig["ca_file"].(string); ok </span><span class="cov0" title="0">{
                                tlsCfg.CAFile = caFile
                        }</span>
                        <span class="cov0" title="0">if skipVerify, ok := tlsConfig["insecure_skip_verify"].(bool); ok </span><span class="cov0" title="0">{
                                tlsCfg.InsecureSkipVerify = skipVerify
                        }</span>
                        <span class="cov0" title="0">if minVersion, ok := tlsConfig["min_version"].(string); ok </span><span class="cov0" title="0">{
                                tlsCfg.MinVersion = minVersion
                        }</span>
                        <span class="cov0" title="0">if maxVersion, ok := tlsConfig["max_version"].(string); ok </span><span class="cov0" title="0">{
                                tlsCfg.MaxVersion = maxVersion
                        }</span>
                        
                        <span class="cov0" title="0">tlsConfigObj, err := security.NewTLSConfig(tlsCfg)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("创建TLS配置失败: %w", err)
                        }</span>
                        <span class="cov0" title="0">if tlsConfigObj != nil </span><span class="cov0" title="0">{
                                saramaConfig.Net.TLS.Enable = true
                                saramaConfig.Net.TLS.Config = tlsConfigObj
                        }</span>
                }
        }
        
        // SASL配置
        <span class="cov8" title="1">if cfg.SecurityProtocol == "SASL_PLAINTEXT" || cfg.SecurityProtocol == "SASL_SSL" </span><span class="cov0" title="0">{
                saramaConfig.Net.SASL.Enable = true
                saramaConfig.Net.SASL.Mechanism = sarama.SASLTypePlaintext
                saramaConfig.Net.SASL.User = cfg.SASLUsername
                saramaConfig.Net.SASL.Password = cfg.SASLPassword
        }</span>

        // 创建消费者组
        <span class="cov8" title="1">consumer, err := sarama.NewConsumerGroup(cfg.Brokers, cfg.GroupID, saramaConfig)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("创建Kafka消费者组失败: %w", err)
        }</span>

        <span class="cov0" title="0">p.consumer = consumer
        p.msgChan = make(chan *Message, cfg.BatchSize*2)
        p.handler = &amp;kafkaConsumerGroupHandler{
                msgChan: p.msgChan,
                stats:   p.stats,
                statsMu: &amp;p.statsMu,
        }

        return nil</span>
}

// Start 启动插件
func (p *KafkaPlugin) Start(ctx context.Context) error <span class="cov0" title="0">{
        topics := p.getTopics()
        if len(topics) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("没有配置要消费的topics")
        }</span>

        <span class="cov0" title="0">log.Printf("[Kafka插件] 开始消费topics: %v", topics)

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                if err := p.consumer.Consume(ctx, topics, p.handler); err != nil </span><span class="cov0" title="0">{
                                        p.statsMu.Lock()
                                        p.stats.Errors++
                                        p.statsMu.Unlock()
                                        log.Printf("[Kafka插件] 消费错误: %v", err)
                                        time.Sleep(1 * time.Second)
                                }</span>
                        }
                }
        }()

        <span class="cov0" title="0">return nil</span>
}

// Stop 停止插件
func (p *KafkaPlugin) Stop() error <span class="cov0" title="0">{
        if p.consumer != nil </span><span class="cov0" title="0">{
                if err := p.consumer.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if p.msgChan != nil </span><span class="cov0" title="0">{
                close(p.msgChan)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Messages 返回消息通道
func (p *KafkaPlugin) Messages() &lt;-chan *Message <span class="cov0" title="0">{
        return p.msgChan
}</span>

// Ack 确认消息（Kafka通过自动提交offset实现）
func (p *KafkaPlugin) Ack(msg *Message) error <span class="cov8" title="1">{
        p.statsMu.Lock()
        p.stats.MessagesAcked++
        p.statsMu.Unlock()
        return nil
}</span>

// GetStats 获取统计信息
func (p *KafkaPlugin) GetStats() PluginStats <span class="cov8" title="1">{
        p.statsMu.RLock()
        defer p.statsMu.RUnlock()

        return PluginStats{
                MessagesReceived: p.stats.MessagesReceived,
                MessagesAcked:    p.stats.MessagesAcked,
                Errors:           p.stats.Errors,
                LastMessageTime:  p.stats.LastMessageTime,
                StartTime:        p.stats.StartTime,
        }
}</span>

// getTopics 获取要消费的topics列表
func (p *KafkaPlugin) getTopics() []string <span class="cov0" title="0">{
        if p.config.Topic != "" </span><span class="cov0" title="0">{
                return []string{p.config.Topic}
        }</span>
        <span class="cov0" title="0">if len(p.config.Topics) &gt; 0 </span><span class="cov0" title="0">{
                return p.config.Topics
        }</span>
        <span class="cov0" title="0">return []string{}</span>
}

func init() <span class="cov8" title="1">{
        RegisterPlugin("kafka", NewKafkaPlugin)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package plugins

import (
        "context"
        "time"
)

// Message 统一的消息格式
type Message struct {
        Key       []byte
        Value     []byte
        Headers   map[string][]byte
        Timestamp time.Time
        Source    string // 消息来源标识
        Metadata  map[string]interface{} // 额外的元数据，插件可以自定义
}

// SourcePlugin 数据源插件接口
type SourcePlugin interface {
        // Name 返回插件名称
        Name() string

        // Initialize 初始化插件，传入配置
        Initialize(config map[string]interface{}) error

        // Start 启动插件，开始消费消息
        Start(ctx context.Context) error

        // Stop 停止插件
        Stop() error

        // Messages 返回消息通道
        Messages() &lt;-chan *Message

        // Ack 确认消息已处理（可选，某些插件可能需要）
        Ack(msg *Message) error

        // GetStats 获取插件统计信息
        GetStats() PluginStats
}

// PluginStats 插件统计信息
type PluginStats struct {
        MessagesReceived int64
        MessagesAcked    int64
        Errors           int64
        LastMessageTime  time.Time
        StartTime        time.Time
}

// PluginRegistry 插件注册表
type PluginRegistry struct {
        plugins map[string]func() SourcePlugin
}

var globalRegistry = &amp;PluginRegistry{
        plugins: make(map[string]func() SourcePlugin),
}

// Register 注册插件
func (r *PluginRegistry) Register(name string, factory func() SourcePlugin) <span class="cov8" title="1">{
        r.plugins[name] = factory
}</span>

// Create 创建插件实例
func (r *PluginRegistry) Create(name string) (SourcePlugin, error) <span class="cov8" title="1">{
        factory, ok := r.plugins[name]
        if !ok </span><span class="cov8" title="1">{
                return nil, &amp;PluginNotFoundError{Name: name}
        }</span>
        <span class="cov8" title="1">return factory(), nil</span>
}

// List 列出所有已注册的插件
func (r *PluginRegistry) List() []string <span class="cov8" title="1">{
        names := make([]string, 0, len(r.plugins))
        for name := range r.plugins </span><span class="cov8" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov8" title="1">return names</span>
}

// PluginNotFoundError 插件未找到错误
type PluginNotFoundError struct {
        Name string
}

func (e *PluginNotFoundError) Error() string <span class="cov0" title="0">{
        return "插件未找到: " + e.Name
}</span>

// RegisterPlugin 全局函数：注册插件
func RegisterPlugin(name string, factory func() SourcePlugin) <span class="cov8" title="1">{
        globalRegistry.Register(name, factory)
}</span>

// CreatePlugin 全局函数：创建插件实例
func CreatePlugin(name string) (SourcePlugin, error) <span class="cov8" title="1">{
        return globalRegistry.Create(name)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package plugins

import (
        "context"
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/streadway/amqp"
)

// RabbitMQPlugin RabbitMQ数据源插件
type RabbitMQPlugin struct {
        config     *RabbitMQPluginConfig
        conn       *amqp.Connection
        channel    *amqp.Channel
        msgChan    chan *Message
        stats      *RabbitMQPluginStats
        statsMu    sync.RWMutex
        ctx        context.Context
        cancel     context.CancelFunc
}

// RabbitMQPluginConfig RabbitMQ插件配置
type RabbitMQPluginConfig struct {
        URL      string
        Exchange string
        Queue    string
        QueueOptions *RabbitMQQueueOptions
}

// RabbitMQQueueOptions 队列选项
type RabbitMQQueueOptions struct {
        Durable    bool
        AutoDelete bool
        Exclusive  bool
        NoWait     bool
}

// RabbitMQPluginStats RabbitMQ插件统计信息
type RabbitMQPluginStats struct {
        MessagesReceived int64
        MessagesAcked    int64
        Errors           int64
        LastMessageTime  time.Time
        StartTime        time.Time
}

// NewRabbitMQPlugin 创建RabbitMQ插件实例
func NewRabbitMQPlugin() SourcePlugin <span class="cov8" title="1">{
        return &amp;RabbitMQPlugin{
                stats: &amp;RabbitMQPluginStats{
                        StartTime: time.Now(),
                },
        }
}</span>

// Name 返回插件名称
func (p *RabbitMQPlugin) Name() string <span class="cov8" title="1">{
        return "rabbitmq"
}</span>

// Initialize 初始化插件
func (p *RabbitMQPlugin) Initialize(config map[string]interface{}) error <span class="cov8" title="1">{
        cfg := &amp;RabbitMQPluginConfig{}

        if url, ok := config["url"].(string); ok </span><span class="cov8" title="1">{
                cfg.URL = url
        }</span> else<span class="cov0" title="0"> {
                cfg.URL = "amqp://guest:guest@localhost:5672/"
        }</span>

        <span class="cov8" title="1">if exchange, ok := config["exchange"].(string); ok </span><span class="cov8" title="1">{
                cfg.Exchange = exchange
        }</span>

        <span class="cov8" title="1">if queue, ok := config["queue"].(string); ok </span><span class="cov8" title="1">{
                cfg.Queue = queue
        }</span> else<span class="cov0" title="0"> {
                return fmt.Errorf("queue配置不能为空")
        }</span>

        // 队列选项
        <span class="cov8" title="1">cfg.QueueOptions = &amp;RabbitMQQueueOptions{
                Durable:    true,
                AutoDelete: false,
                Exclusive:  false,
                NoWait:     false,
        }

        if queueOpts, ok := config["queue_options"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if durable, ok := queueOpts["durable"].(bool); ok </span><span class="cov0" title="0">{
                        cfg.QueueOptions.Durable = durable
                }</span>
                <span class="cov0" title="0">if autoDelete, ok := queueOpts["auto_delete"].(bool); ok </span><span class="cov0" title="0">{
                        cfg.QueueOptions.AutoDelete = autoDelete
                }</span>
                <span class="cov0" title="0">if exclusive, ok := queueOpts["exclusive"].(bool); ok </span><span class="cov0" title="0">{
                        cfg.QueueOptions.Exclusive = exclusive
                }</span>
        }

        <span class="cov8" title="1">p.config = cfg
        p.msgChan = make(chan *Message, 100)

        return nil</span>
}

// Start 启动插件
func (p *RabbitMQPlugin) Start(ctx context.Context) error <span class="cov8" title="1">{
        p.ctx, p.cancel = context.WithCancel(ctx)

        // 连接RabbitMQ
        var err error
        p.conn, err = amqp.Dial(p.config.URL)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("连接RabbitMQ失败: %w", err)
        }</span>

        <span class="cov0" title="0">p.channel, err = p.conn.Channel()
        if err != nil </span><span class="cov0" title="0">{
                p.conn.Close()
                return fmt.Errorf("创建RabbitMQ通道失败: %w", err)
        }</span>

        // 声明队列
        <span class="cov0" title="0">_, err = p.channel.QueueDeclare(
                p.config.Queue,
                p.config.QueueOptions.Durable,
                p.config.QueueOptions.AutoDelete,
                p.config.QueueOptions.Exclusive,
                p.config.QueueOptions.NoWait,
                nil,
        )
        if err != nil </span><span class="cov0" title="0">{
                p.channel.Close()
                p.conn.Close()
                return fmt.Errorf("声明队列失败: %w", err)
        }</span>

        // 如果有exchange，绑定队列
        <span class="cov0" title="0">if p.config.Exchange != "" </span><span class="cov0" title="0">{
                err = p.channel.QueueBind(
                        p.config.Queue,
                        "", // routing key
                        p.config.Exchange,
                        false,
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        p.channel.Close()
                        p.conn.Close()
                        return fmt.Errorf("绑定队列到exchange失败: %w", err)
                }</span>
        }

        // 设置QoS
        <span class="cov0" title="0">err = p.channel.Qos(
                1,     // prefetch count
                0,     // prefetch size
                false, // global
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[RabbitMQ插件] 设置QoS失败: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("[RabbitMQ插件] 开始消费队列: %s", p.config.Queue)

        // 开始消费消息
        deliveries, err := p.channel.Consume(
                p.config.Queue,
                "",    // consumer
                false, // auto-ack
                false, // exclusive
                false, // no-local
                false, // no-wait
                nil,   // args
        )
        if err != nil </span><span class="cov0" title="0">{
                p.channel.Close()
                p.conn.Close()
                return fmt.Errorf("开始消费失败: %w", err)
        }</span>

        // 处理消息
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer p.cancel()
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-p.ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case delivery, ok := &lt;-deliveries:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        log.Printf("[RabbitMQ插件] 消息通道已关闭")
                                        return
                                }</span>

                                // 转换为统一消息格式
                                <span class="cov0" title="0">msg := &amp;Message{
                                        Key:       []byte(delivery.MessageId),
                                        Value:     delivery.Body,
                                        Headers:   convertRabbitMQHeaders(delivery.Headers),
                                        Timestamp: delivery.Timestamp,
                                        Source:    "rabbitmq",
                                        Metadata: map[string]interface{}{
                                                "exchange":     delivery.Exchange,
                                                "routing_key":  delivery.RoutingKey,
                                                "delivery_tag": delivery.DeliveryTag,
                                                "delivery":     delivery, // 保存原始delivery用于ack
                                        },
                                }

                                // 更新统计
                                p.statsMu.Lock()
                                p.stats.MessagesReceived++
                                p.stats.LastMessageTime = time.Now()
                                p.statsMu.Unlock()

                                // 发送消息
                                select </span>{
                                case p.msgChan &lt;- msg:<span class="cov0" title="0"></span>
                                case &lt;-p.ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }
        }()

        <span class="cov0" title="0">return nil</span>
}

// Stop 停止插件
func (p *RabbitMQPlugin) Stop() error <span class="cov8" title="1">{
        if p.cancel != nil </span><span class="cov8" title="1">{
                p.cancel()
        }</span>
        <span class="cov8" title="1">if p.channel != nil </span><span class="cov0" title="0">{
                p.channel.Close()
        }</span>
        <span class="cov8" title="1">if p.conn != nil </span><span class="cov0" title="0">{
                p.conn.Close()
        }</span>
        <span class="cov8" title="1">if p.msgChan != nil </span><span class="cov8" title="1">{
                close(p.msgChan)
        }</span>
        <span class="cov8" title="1">log.Println("[RabbitMQ插件] 已停止")
        return nil</span>
}

// Messages 返回消息通道
func (p *RabbitMQPlugin) Messages() &lt;-chan *Message <span class="cov8" title="1">{
        return p.msgChan
}</span>

// Ack 确认消息
func (p *RabbitMQPlugin) Ack(msg *Message) error <span class="cov8" title="1">{
        if delivery, ok := msg.Metadata["delivery"].(amqp.Delivery); ok </span><span class="cov0" title="0">{
                err := delivery.Ack(false)
                if err != nil </span><span class="cov0" title="0">{
                        p.statsMu.Lock()
                        p.stats.Errors++
                        p.statsMu.Unlock()
                        return fmt.Errorf("确认消息失败: %w", err)
                }</span>

                <span class="cov0" title="0">p.statsMu.Lock()
                p.stats.MessagesAcked++
                p.statsMu.Unlock()</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetStats 获取统计信息
func (p *RabbitMQPlugin) GetStats() PluginStats <span class="cov8" title="1">{
        p.statsMu.RLock()
        defer p.statsMu.RUnlock()

        return PluginStats{
                MessagesReceived: p.stats.MessagesReceived,
                MessagesAcked:    p.stats.MessagesAcked,
                Errors:           p.stats.Errors,
                LastMessageTime:  p.stats.LastMessageTime,
                StartTime:        p.stats.StartTime,
        }
}</span>

// convertRabbitMQHeaders 转换RabbitMQ消息头
func convertRabbitMQHeaders(headers amqp.Table) map[string][]byte <span class="cov8" title="1">{
        if len(headers) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">result := make(map[string][]byte)
        for k, v := range headers </span><span class="cov8" title="1">{
                switch val := v.(type) </span>{
                case string:<span class="cov8" title="1">
                        result[k] = []byte(val)</span>
                case []byte:<span class="cov8" title="1">
                        result[k] = val</span>
                case []interface{}:<span class="cov0" title="0">
                        // 处理数组类型的header
                        bytes := make([]byte, 0)
                        for _, item := range val </span><span class="cov0" title="0">{
                                if b, ok := item.([]byte); ok </span><span class="cov0" title="0">{
                                        bytes = append(bytes, b...)
                                }</span>
                        }
                        <span class="cov0" title="0">result[k] = bytes</span>
                }
        }
        <span class="cov8" title="1">return result</span>
}

func init() <span class="cov8" title="1">{
        RegisterPlugin("rabbitmq", NewRabbitMQPlugin)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package web

// GetWebUIHTML 返回Web UI的HTML内容
func GetWebUIHTML() string <span class="cov0" title="0">{
        return `&lt;!DOCTYPE html&gt;
&lt;html lang="zh-CN"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Message Mirror - 配置管理&lt;/title&gt;
    &lt;style&gt;
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #1890ff;
            margin-bottom: 10px;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: #f0f0f0;
            border-radius: 4px;
            transition: all 0.3s;
        }
        .tab.active {
            background: #1890ff;
            color: #fff;
        }
        .tab-content {
            display: none;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .tab-content.active {
            display: block;
        }
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }
        input, select, textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d9d9d9;
            border-radius: 4px;
            font-size: 14px;
        }
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #1890ff;
        }
        textarea {
            min-height: 100px;
            font-family: monospace;
            resize: vertical;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        .btn-primary {
            background: #1890ff;
            color: #fff;
        }
        .btn-primary:hover {
            background: #40a9ff;
        }
        .btn-success {
            background: #52c41a;
            color: #fff;
        }
        .btn-success:hover {
            background: #73d13d;
        }
        .btn-danger {
            background: #ff4d4f;
            color: #fff;
        }
        .btn-danger:hover {
            background: #ff7875;
        }
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .alert {
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .alert-success {
            background: #f6ffed;
            border: 1px solid #b7eb8f;
            color: #52c41a;
        }
        .alert-error {
            background: #fff2f0;
            border: 1px solid #ffccc7;
            color: #ff4d4f;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #1890ff;
        }
        .stat-label {
            color: #999;
            font-size: 14px;
            margin-top: 5px;
        }
        .json-editor {
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        .section {
            margin-bottom: 30px;
        }
        .section-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #1890ff;
            padding-bottom: 5px;
        }
        .row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        @media (max-width: 768px) {
            .row {
                grid-template-columns: 1fr;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;header&gt;
            &lt;h1&gt;Message Mirror 配置管理&lt;/h1&gt;
            &lt;p&gt;实时配置管理和监控&lt;/p&gt;
        &lt;/header&gt;

        &lt;div class="tabs"&gt;
            &lt;button class="tab active" onclick="switchTab('config')"&gt;配置管理&lt;/button&gt;
            &lt;button class="tab" onclick="switchTab('stats')"&gt;统计信息&lt;/button&gt;
        &lt;/div&gt;

        &lt;div id="alert-container"&gt;&lt;/div&gt;

        &lt;div id="config-tab" class="tab-content active"&gt;
            &lt;div class="section"&gt;
                &lt;div class="section-title"&gt;数据源配置&lt;/div&gt;
                &lt;div class="form-group"&gt;
                    &lt;label&gt;数据源类型&lt;/label&gt;
                    &lt;select id="source-type"&gt;
                        &lt;option value="kafka"&gt;Kafka&lt;/option&gt;
                        &lt;option value="rabbitmq"&gt;RabbitMQ&lt;/option&gt;
                        &lt;option value="file"&gt;文件监控&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/div&gt;
                &lt;div id="source-config"&gt;&lt;/div&gt;
            &lt;/div&gt;

            &lt;div class="section"&gt;
                &lt;div class="section-title"&gt;目标配置&lt;/div&gt;
                &lt;div class="form-group"&gt;
                    &lt;label&gt;Brokers (逗号分隔)&lt;/label&gt;
                    &lt;input type="text" id="target-brokers" placeholder="localhost:9092,localhost:9093"&gt;
                &lt;/div&gt;
                &lt;div class="form-group"&gt;
                    &lt;label&gt;Topic&lt;/label&gt;
                    &lt;input type="text" id="target-topic" placeholder="target-topic"&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class="section"&gt;
                &lt;div class="section-title"&gt;镜像配置&lt;/div&gt;
                &lt;div class="row"&gt;
                    &lt;div class="form-group"&gt;
                        &lt;label&gt;Worker数量&lt;/label&gt;
                        &lt;input type="number" id="worker-count" min="1" value="4"&gt;
                    &lt;/div&gt;
                    &lt;div class="form-group"&gt;
                        &lt;label&gt;批处理大小&lt;/label&gt;
                        &lt;input type="number" id="batch-size" min="1" value="100"&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="row"&gt;
                    &lt;div class="form-group"&gt;
                        &lt;label&gt;消费速率限制 (消息/秒, 0=不限制)&lt;/label&gt;
                        &lt;input type="number" id="consumer-rate-limit" min="0" value="0" step="0.1"&gt;
                    &lt;/div&gt;
                    &lt;div class="form-group"&gt;
                        &lt;label&gt;生产速率限制 (消息/秒, 0=不限制)&lt;/label&gt;
                        &lt;input type="number" id="producer-rate-limit" min="0" value="0" step="0.1"&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="form-group"&gt;
                    &lt;label&gt;
                        &lt;input type="checkbox" id="batch-enabled"&gt; 启用批处理
                    &lt;/label&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class="section"&gt;
                &lt;div class="section-title"&gt;高级配置 (JSON)&lt;/div&gt;
                &lt;div class="form-group"&gt;
                    &lt;textarea id="config-json" class="json-editor" placeholder="完整配置JSON..."&gt;&lt;/textarea&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class="btn-group"&gt;
                &lt;button class="btn btn-primary" onclick="loadConfig()"&gt;加载配置&lt;/button&gt;
                &lt;button class="btn btn-success" onclick="saveConfig()"&gt;保存配置&lt;/button&gt;
                &lt;button class="btn btn-primary" onclick="reloadConfig()"&gt;重载配置&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div id="stats-tab" class="tab-content"&gt;
            &lt;div class="stats-grid" id="stats-grid"&gt;&lt;/div&gt;
            &lt;button class="btn btn-primary" onclick="loadStats()"&gt;刷新统计&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        let currentConfig = null;

        function switchTab(tab) {
            document.querySelectorAll('.tab').forEach(t =&gt; t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c =&gt; c.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tab + '-tab').classList.add('active');
        }

        function showAlert(message, type) {
            const container = document.getElementById('alert-container');
            container.innerHTML = '&lt;div class="alert alert-' + type + '"&gt;' + message + '&lt;/div&gt;';
            setTimeout(() =&gt; {
                container.innerHTML = '';
            }, 5000);
        }

        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                if (!response.ok) throw new Error('加载配置失败');
                const config = await response.json();
                currentConfig = config;
                populateForm(config);
                showAlert('配置加载成功', 'success');
            } catch (error) {
                showAlert('加载配置失败: ' + error.message, 'error');
            }
        }

        function populateForm(config) {
            if (config.source) {
                document.getElementById('source-type').value = config.source.type || 'kafka';
            }
            if (config.target) {
                document.getElementById('target-brokers').value = (config.target.brokers || []).join(',');
                document.getElementById('target-topic').value = config.target.topic || '';
            }
            if (config.mirror) {
                document.getElementById('worker-count').value = config.mirror.worker_count || 4;
                document.getElementById('batch-size').value = config.mirror.batch_size || 100;
                document.getElementById('consumer-rate-limit').value = config.mirror.consumer_rate_limit || 0;
                document.getElementById('producer-rate-limit').value = config.mirror.producer_rate_limit || 0;
                document.getElementById('batch-enabled').checked = config.mirror.batch_enabled || false;
            }
            document.getElementById('config-json').value = JSON.stringify(config, null, 2);
        }

        async function saveConfig() {
            try {
                const jsonText = document.getElementById('config-json').value;
                let config;
                try {
                    config = JSON.parse(jsonText);
                } catch (e) {
                    // 如果JSON无效，从表单构建配置
                    config = buildConfigFromForm();
                }

                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || '保存配置失败');
                }

                showAlert('配置保存成功，已热重载', 'success');
                currentConfig = config;
            } catch (error) {
                showAlert('保存配置失败: ' + error.message, 'error');
            }
        }

        function buildConfigFromForm() {
            const config = currentConfig || {};
            config.source = config.source || {};
            config.target = config.target || {};
            config.mirror = config.mirror || {};

            config.source.type = document.getElementById('source-type').value;
            config.target.brokers = document.getElementById('target-brokers').value.split(',').map(s =&gt; s.trim()).filter(s =&gt; s);
            config.target.topic = document.getElementById('target-topic').value;
            config.mirror.worker_count = parseInt(document.getElementById('worker-count').value) || 4;
            config.mirror.batch_size = parseInt(document.getElementById('batch-size').value) || 100;
            config.mirror.consumer_rate_limit = parseFloat(document.getElementById('consumer-rate-limit').value) || 0;
            config.mirror.producer_rate_limit = parseFloat(document.getElementById('producer-rate-limit').value) || 0;
            config.mirror.batch_enabled = document.getElementById('batch-enabled').checked;

            return config;
        }

        async function reloadConfig() {
            try {
                const response = await fetch('/api/config/reload', { method: 'POST' });
                if (!response.ok) throw new Error('重载配置失败');
                showAlert('配置已从文件重载', 'success');
                await loadConfig();
            } catch (error) {
                showAlert('重载配置失败: ' + error.message, 'error');
            }
        }

        async function loadStats() {
            try {
                const response = await fetch('/api/stats');
                if (!response.ok) throw new Error('加载统计失败');
                const stats = await response.json();
                displayStats(stats);
            } catch (error) {
                showAlert('加载统计失败: ' + error.message, 'error');
            }
        }

        function displayStats(stats) {
            const grid = document.getElementById('stats-grid');
            const consumed = stats.messages_consumed || 0;
            const produced = stats.messages_produced || 0;
            const bytesConsumed = (stats.bytes_consumed / 1024 / 1024).toFixed(2);
            const bytesProduced = (stats.bytes_produced / 1024 / 1024).toFixed(2);
            const errors = stats.errors || 0;
            const uptimeHours = Math.floor(stats.uptime_seconds / 3600);
            const uptimeMinutes = Math.floor((stats.uptime_seconds % 3600) / 60);
            grid.innerHTML = 
                '&lt;div class="stat-card"&gt;' +
                    '&lt;div class="stat-value"&gt;' + consumed + '&lt;/div&gt;' +
                    '&lt;div class="stat-label"&gt;消费消息数&lt;/div&gt;' +
                '&lt;/div&gt;' +
                '&lt;div class="stat-card"&gt;' +
                    '&lt;div class="stat-value"&gt;' + produced + '&lt;/div&gt;' +
                    '&lt;div class="stat-label"&gt;生产消息数&lt;/div&gt;' +
                '&lt;/div&gt;' +
                '&lt;div class="stat-card"&gt;' +
                    '&lt;div class="stat-value"&gt;' + bytesConsumed + ' MB&lt;/div&gt;' +
                    '&lt;div class="stat-label"&gt;消费字节数&lt;/div&gt;' +
                '&lt;/div&gt;' +
                '&lt;div class="stat-card"&gt;' +
                    '&lt;div class="stat-value"&gt;' + bytesProduced + ' MB&lt;/div&gt;' +
                    '&lt;div class="stat-label"&gt;生产字节数&lt;/div&gt;' +
                '&lt;/div&gt;' +
                '&lt;div class="stat-card"&gt;' +
                    '&lt;div class="stat-value"&gt;' + errors + '&lt;/div&gt;' +
                    '&lt;div class="stat-label"&gt;错误数&lt;/div&gt;' +
                '&lt;/div&gt;' +
                '&lt;div class="stat-card"&gt;' +
                    '&lt;div class="stat-value"&gt;' + uptimeHours + 'h ' + uptimeMinutes + 'm&lt;/div&gt;' +
                    '&lt;div class="stat-label"&gt;运行时间&lt;/div&gt;' +
                '&lt;/div&gt;';
        }

        // 页面加载时自动加载配置和统计
        window.onload = function() {
            loadConfig();
            loadStats();
            setInterval(loadStats, 5000); // 每5秒刷新统计
        };
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`
}</span>

</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
